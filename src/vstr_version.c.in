#define VSTR_VERSION_C
/*
 *  Copyright (C) 1999, 2000, 2001, 2002  James Antill
 *  
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *   
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *   
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 *  email: james@and.org
 */

/* prints the version and some info out when you run the library */

#include "main.h"

/* syscall on Linux x86 doesn't work in a shared library as the PIC code 
 * uses %bx. If you are compiling for static only, the this should work.
 * However then you can't run the library anyway.
 * 
 * Code does inline asm for i386 Linux */
#define TST_SYSCALL 0

#if TST_SYSCALL || (defined(HAVE_SYSCALL_H) && defined(USE_SYSCALL))
#include <syscall.h>

# define write(x, y, z) vstr__sys_write(x, y, z)
static _syscall3(int, write, int, fd, const void *, buf, int, count)
# define exit(x) vstr__sys_exit(x)
static _syscall1(int, exit, int, ret)
#endif

void vstr_version_func(void)
{
  int fd = 1;
  const char *const msg = "\n"
       "Vstr library release version -- @VERSION@ --, by James Antill.\n"
       "Copyright (C) 1999, 2000, 2001, 2002 James Antill.\n"
       "This is free software; see the source for copying conditions.\n"
       "There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n"
       "PARTICULAR PURPOSE.\n\n"
       "Configured as follows:\n"
       "    Compiled on " __DATE__ " at " __TIME__ ".\n"

    
#ifndef NDEBUG
 "    Debugging enabled (CFLAGS = @CFLAGS@).\n"
#else
 "    No debugging (CFLAGS = @CFLAGS@)\n"
#endif

#ifdef HAVE_POSIX_HOST
 "    Running on a POSIX host.\n"
#else
 "    No POSIX host (iovec is manually defined, and vstr_sc_* are stubs)\n"
#endif

#ifdef HAVE_MMAP
 "    Have mmap system call.\n"
#endif
    
#if USE_RESTRICTED_HEADERS
 "    Compiled with restricted functionality in lib C.\n"
#endif
    
#if defined(VSTR_AUTOCONF_FMT_DBL_glibc)
 "    Formatting floats using -- glibc -- code.\n"
#elif defined(VSTR_AUTOCONF_FMT_DBL_none)
 "    Formatting floats using -- none -- code (all floats are treated as zero).\n"
#elif defined(VSTR_AUTOCONF_FMT_DBL_host)
 "    Formatting floats using -- host -- code.\n"
#else
# error "Please configure properly..."
#endif

    
#ifdef HAVE_LINKER_SCRIPT
 "    Linker script enabled (suppresses internal symbols).\n"
#endif

#ifdef HAVE_ATTRIB_ALIAS
 "    Compiler supports -- alias -- attribute.\n"
#endif

#ifdef HAVE_ATTRIB_DEPRECATED
 "    Compiler supports -- deprecated -- attribute.\n"
#endif

#ifdef HAVE_ATTRIB_VISIBILITY
 "    Compiler supports -- visibility -- attribute.\n"
#endif

#ifdef HAVE_INLINE
 "    Functions can be inlined for speed.\n"
#else
 "    Functions cannot be inlined by the environment.\n"
#endif

    
 "\n"
"Information can be found at:                          http://www.and.org/vstr/"
       "\n"
"Bug reports should be sent to:                    James Antill <james@and.org>"
       "\n\n"
    ;

  const char *scan = NULL;
  int len = 0;

#if (!TST_SYSCALL) && (defined(__linux__) && defined(__i386__))
 /* this is sick, but works. */

 /* write syscall for Linux x86 */
#  define VSTR__SYS_WRITE(ret, fd, msg, len) \
  __asm__ __volatile__ ("\
mov     $4, %%eax\n\t\
mov     %1, %%ebx\n\t\
mov     %2, %%ecx\n\t\
mov     %3, %%edx\n\t\
int     $0x80\n\t\
" : "=a"(ret) : "m"(fd), "m"(msg), "m"(len))

  /* exit syscall for Linux x86 */
#  define VSTR__SYS_EXIT(ret) do { int num = (ret); \
  __asm__ __volatile__ ("\
mov     $1, %%eax\n\t\
mov     %0, %%ebx\n\t\
int     $0x80\n\t\
" : : "m"(num)); } while (FALSE)

#elif TST_SYSCALL || (defined(HAVE_SYSCALL_H) && defined(USE_SYSCALL))
 /* syscall code for write/exit */
 /* See above for actual syscall implimentations */

#  define VSTR__SYS_WRITE(ret, fd, msg, len) ret = vstr__sys_write(fd, msg, len)
#  define VSTR__SYS_EXIT(ret) vstr__sys_exit(ret)

#else
  /* this is obvious, well apart from the fact that it doesn't work unless
   * run via. ld.so */
#  define VSTR__SYS_WRITE(ret, fd, msg, len) ret = write(fd, msg, len)
#  define VSTR__SYS_EXIT(ret) _exit(ret)
#endif

  scan = msg;
  while (*scan++) ++len;
  scan = msg;

  while (len)
  {
    int ret = -1;

    VSTR__SYS_WRITE(ret, fd, scan, len);

    if (ret < 0)
      VSTR__SYS_EXIT(EXIT_FAILURE);

    len -= ret;
  }

  VSTR__SYS_EXIT(EXIT_SUCCESS);
}
