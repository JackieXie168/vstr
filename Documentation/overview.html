<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Vstr documentation -- overview</title>

    <style>
      A:visited { color: #ff4040; }
      A:hover { color: #20b2aa; }

      P { text-indent: 1cm; }

      body { background: #FFFFFF; }

      td.heading { background: #DDDDDD; }
    </style>

  </head>

  <body bgcolor="#FFFFFF">
    <h1>Vstr documentation -- overview</h1>

    <table width="90%"><tr><td bgcolor="#DDDDFF">
	  <h2>About</h2>
	</td></tr></table>
    
    <table width="80%"><tr><td>
	  <p>
	    This is a string library, it's designed so you can work optimally
	    with readv()/writev() for input/output. This means that, for 
	    instance, you can readv() data to the end of the string and
	    writev() data from the begining of the string without having to
	    allocate or move memory. It also
	    means that the library is completely happy with data that has
	    multiple zero bytes in it.
	  </p>
	  <p>
	    This design constraint means that unlike
	    most string libraries Vstr doesn't have an internal representation 
	    of the string where everything can be accessed from a single
	    (char *) pointer in C, the internal representation is of multiple
	    "blocks" or nodes each carrying some of the data for the string.
	    This model of representing the data also means that as a string gets
	    bigger the Vstr memory usage only goes up linearly and has no 
	    inherent copying (due to other string libraries increasing space
	    for the string via. realloc() the memory usage can almost double and
	    require a complete copy of the string).
	  </p>
	  <p>
	    It also means that adding, substituting or moving data anywhere in
	    the string can be optimised a lot, to require O(1) copying instead 
	    of O(n).
	    Speaking of O(1), it's worth remembering that if you have a 
	    Vstr string with caching enabled a writev() call will take 
	    constant time as well (the cat example below shows an example of
	    this, the write call is <emp>always constant time</emp>.
	  </p>
	  
	  As well as having features directly related to doing IO well
	  it contains functions for:
	  <ul>
	    <li> a printf like function that is fully ISO C 9899:1999 (C99)
	      compliant, also having %m as standard and POSIX i18n parameter
	      number modifiers. It also allows gcc warning compatible customer
	      format specifiers (and includes pre-written custom format
	      specifiers for ipv4 and ipv6 addresses, Vstr strings and more)
	    <li> splitting of strings into parameter/record chunks (a la perl).
	    <li> substituting data in a Vstr string
	    <li> moving data from one Vstr string to another (or within a Vstr
	      string).
	    <li> comparing strings (without regard for case, or taking into
	      account version information)
	    <li> searching for data in strings (with or without regard for 
	      case).
	    <li> counting spans of data in a string (the equivalent of
	      strspn() in ISO C).
	    <li> converting data in a Vstr (Ie. delete/substitute unprintable 
	      characters or makeing a Vstr string lowercase/uppercase).
	    <li> parsing data from a Vstr string (Ie. numbers, or ipv4 
	      addresses).
	    <li> easily parsing and wrapping outgoing data in netstrings, for
	      fast and simple (and hence less error prone) network communication
	    <li> the ability to cache aspects of data about a Vstr string, to
	      both simplify and speedup use of the string.
	  </ul>
	  It also has a number of functions for exporting data from a
	  Vstr string so you can easily use data generted with the Vstr 
	  outside of the library.
	  
	  <p>
	    The other unusual aspect of the Vstr string library is that it 
	    attaches a notion of a locale to the string configuration
	    and not globally (as POSIX, and pretty much everything else does).
	    This means that you can do Network I/O in the C locale and
	    user IO in the users locale.
	  </p>

	  <p>
	    A last point that shouldn't be unusual, but is. The Vstr string 
	    library comes with a "make check" test suite with over <emp>four 
	    thousand lines</emp> of code in it, so although you can never say 
	    something is bug free you have an assurance that most things
	    will work as advertised.
	  </p>
	    
	  <p>
	    For a comparison with other string libraries and printf() like
	    implementations, see
	    <a href="comparison.html">this page</a>.
	  </p>

</td></tr>

</table>

<table width="90%"><tr><td bgcolor="#DDDDFF">
	  <h2>A simple introduction to the API</h2>
	</td></tr></table>

<table width="80%"><tr><td><p>

 At first glace the vstr API looks <b>huge</b> as there are over
<b>One hundred and forty</b> functions. However the API was designed so 
that you can mentally build functions from a template in your head ... so 
instead of having to remember 140 functions you just need to remember
10 to 20 pieces of a template.

</p><p>
 All vstr functions obey one of the following template rules...<br>
 <br>
"vstr_" &lt;verb&gt; <br>
"vstr_" &lt;verb&gt;  &lt;noun&gt; <br>
"vstr_" &lt;verb&gt;  &lt;noun&gt;  &lt;verb&gt; <br>
 <br>
...a good example is searching for data in a vstr, here is a list of the
functions that you can use to search for data in a vstr...<br>
 <br>
 vstr_srch_chr_fwd() <br>
 vstr_srch_chr_rev() <br>
 vstr_srch_buf_fwd() <br>
 vstr_srch_buf_rev() <br>
 vstr_srch_chrs_fwd() <br>
 vstr_srch_chrs_rev() <br>
 vstr_srch_vstr_fwd() <br>
 vstr_srch_vstr_rev() <br>
 vstr_srch_case_chr_fwd() <br>
 vstr_srch_case_chr_rev() <br>
 vstr_srch_case_buf_fwd() <br>
 vstr_srch_case_buf_rev() <br>
 vstr_srch_case_vstr_fwd() <br>
 vstr_srch_case_vstr_rev() <br>
 vstr_csrch_chrs_fwd() <br>
 vstr_csrch_chrs_rev() <br>
 vstr_spn_chrs_fwd() <br>
 vstr_spn_chrs_rev() <br>
 vstr_cspn_chrs_fwd() <br>
 vstr_cspn_chrs_rev() <br>
 <br>
...which is a <u>lot</u> of functions (and that doesn't even include the
CSTR macro function variants) just to search for some data. However
that can be broken up into... <br>

<table>
<tr>
<td>"vstr_"</td><td>&lt;verb&gt;</td><td>&lt;noun&gt;</td><td>&lt;verb&gt;</td>
</tr>
<tr><td>"vstr_"</td><td> srch      </td><td> chr  </td><td> fwd </td></tr>
<tr><td>       </td><td> srch_case </td><td> buf  </td><td> rev </td></tr>
<tr><td>       </td><td> csrch     </td><td> vstr </td><td>     </td></tr>
<tr><td>       </td><td> spn       </td><td> chrs </td><td>     </td></tr>
<tr><td>       </td><td> cspn      </td><td>      </td><td>     </td></tr>
</table>
 <br>
...which is much less information to remember.

</p></td></tr>

</table>

<table width="90%"><tr><td bgcolor="#DDDDFF">
	  <h2>Reference Documentation</h2>
	</td></tr></table>

<table width="80%"><tr><td><p>

 All functions are documented in <a href="functions.html">functions.html</a>, 
all constants are in <a href="constants.html">constants.html</a>, all public
members of structures are in <a href="structs.html">structs.html</a>
and the namespace rules are in <a href="namespace.html">namespace.html</a>.

 Note that if you install the library the functions reference is available as
the vstr man page.

</p></td></tr>

</table>

<table width="90%"><tr><td bgcolor="#DDDDFF">
	  <h2>A simple and heavily commented example</h2>
	</td></tr></table>

<table width="80%"><tr><td><p>

 To get a rough overview of how to use the library you can see heavily
commented examples of a simple version of a
<a href="vstr-latest/vstr/examples/ex_cat.c.html">Unix cat</a>program or a
simple version of a
<a href="vstr-latest/vstr/examples/ex_lookup_ip.c.html">hostname lookup</a>
program.</p><p>
 All the example programs are listed from the directory
<a href="vstr-latest/vstr/examples/">HERE</a> and for the truley adventurous
the "make check" test suite root is <a href="vstr-latest/vstr/tst/">HERE</a>
(note that the test suite is written to try and break the Vstr string library,
so although it uses all of the APIs it may not be code you want to copy and 
paste into your programs/libraries).

</p></td></tr>

</table>

    <hr>
    <address><a href="mailto:james@and.org">James Antill</a></address>
<!-- Created: Sun Oct 14 20:53:50 EDT 2001 -->
<!-- hhmts start -->
Last modified: Thu Nov 14 01:33:58 EST 2002
<!-- hhmts end -->
  </body>
</html>
