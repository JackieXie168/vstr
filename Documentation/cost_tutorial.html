<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Costs of dealing with data using Vstr</title>
  </head>

  <body>
    <h1>A tutorial of the costs of dealing with data using Vstr</h1>

<p> This page is an advanced tutorial looking at the costs of the different
Vstr calls, given different data.
For a <a href="tutorial.html">simpler starting tutorial see this page</a>. </p>


<!-- <h2>Adding data to a Vstr_base object</h2> -->
<!-- <h2>Substituting data in a Vstr_base object</h2> -->

<h2>Moving data between Vstr_base objects</h2>

<p> There are five basic methods of moving data from one Vstr to another:  </p>

<ul>
<li><b><a href="functions.html#vstr_add_vstr()">vstr_add_vstr</a>( ..., <a href="constants.html#VSTR_TYPE_ADD_DEF">VSTR_TYPE_ADD_DEF</a>)</b>: This is the generic way
to move data, doing the obvious of copying all nodes. Ie. _BUF in the source becomes copied _BUF data in the dfestination, _NON, _PTR and _REF data makes a
new node with the _NON length, the pointer or the reference.
</li>
<li><b><a href="functions.html#vstr_add_vstr()">vstr_add_vstr</a>( ..., <a href="constants.html#VSTR_TYPE_ADD_BUF_REF">VSTR_TYPE_ADD_BUF_REF</a>)</b>: This converts all _BUF
nodes to _REF nodes, in the source. Then works the same way as
VSTR_TYPE_ADD_DEF. This means that you have to use a _REF node and a Vstr_ref
for each _BUF node in the source, the custom allocation policies in the
Vstr_conf help here. However it also means that all data becomes read-only,
and any alterations will require more _BUF nodes to be allocated in the source
or destination.</li>
<li><b><a href="functions.html#vstr_add_vstr()">vstr_add_vstr</a>( ..., <a href="constants.html#VSTR_TYPE_ADD_BUF_PTR">VSTR_TYPE_ADD_BUF_PTR</a>)</b>: This is like
VSTR_TYPE_ADD_BUF_REF, except that _BUF nodes in the source stay _BUF nodes
(so alterations are unaffected there) and Vstr_ref nodes are not used.  However
it also means that the source should not be altered before the destination has
been deleted, or the data in the destination may be altered or even invalid
memory.</li>
<li><b><a href="functions.html#vstr_add_vstr()">vstr_add_vstr</a>( ..., <a href="constants.html#VSTR_TYPE_ADD_ALL_BUF">VSTR_TYPE_ADD_ALL_BUF</a>)</b>: This option converts
all _PTR and _REF nodes into _BUF nodes, by copying the data in them. </li>
<li><b><a href="functions.html#vstr_mov()">vstr_mov()</a></b>: This function tried to move the data from the
source to the destionation. This means that if you move <b>entire</b> nodes
of data, and you haven't deleted data from the begining of a _BUF node that is
at the begining of the Vstr (or aren't moving that node) and the node sizes for
_BUF nodes are identical (or if the Vstr knows you don't have any _BUF nodes
inside the source) <b>then</b> this operation will just be a few pointer
assingments to move any amount of data. Assuming that you don't have _BUF nodes
or that both _BUF sizes are identical, this function will try and get as close
as possible to just doing the pointer assingments. However the somewhat common
case of moving a partial amount of data from a single _BUF node requres copying
the data in the source so it is in three seperate _BUF nodes, and then moving
the middle node to the destination. This can often require copying more data
than if the simple <a href="functions.html#vstr_add_vstr()">vstr_add_vstr</a>( ..., <a href="constants.html#VSTR_TYPE_ADD_DEF">VSTR_TYPE_ADD_DEF</a>)
 had been used.</li>
</ul>

<h2>Deleting data from a Vstr_base object</h2>

<p> There is only a single call to delete data from a Vstr,
 <a href="functions.html#vstr_del()">vstr_del()</a>, however it has different
speed characteristics depending on what it needs to delete. Much like
<a href="functions.html#vstr_mov()">vstr_mov()</a> the worst case is dealing
with data that doesn't go to the end of a _BUF node, with a single exception.
This requires a single memmove() of all the later data in the node to the start
of the deletion in that node. All node types can delete data form the end of
the node by just changing a variable, nodes can be entirely removed by changing
pointers (although removing pointers from the middle of the Vstr will destroy
the iovec cache -- but that shouldn't be a large hit). All nodes, apart from
_BUF, can delete data from the begining of the node ... <b>and</b> there is
an optimisation so that deleting from the begining of _BUF nodes directly at
the begining of the Vstr requires only a variable alteration (this is a common
operation for IO, add at the end and delete from the begining).
 </p>
 <p> Deleteing from the middle of a non _BUF node is a somewhat faster way of
doing a delete to the end of the node and then an _ADD. Tht means that this
<b>requires an allocation</b>, which is why
<a href="functions.html#vstr_del()">vstr_del()</a>
returns a SUCCESS or FAILURE. This also applies to _BUF nodes when the
<a href="constants.html#VSTR_CNTL_CONF_GET_FLAG_DEL_SPLIT">VSTR_CNTL_CONF_GET_FLAG_DEL_SPLIT</a>
attribute is set in the configuration.
 </p>

    <hr>
    <address><a href="mailto:james@and.org">James Antill</a></address>
<!-- Created: Mon Jan 26 03:10:51 EST 2004 -->
<!-- hhmts start -->
Last modified: Mon Jan 26 05:09:10 EST 2004
<!-- hhmts end -->
  </body>
</html>
