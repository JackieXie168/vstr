<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
<title>Vstr documentation -- constants</title>
    <style type="text/css">
      A:visited { color: #ff4040; }
      A:hover { color: #20b2aa; }

      P { text-indent: 1cm; }

      body { background: #FFFFFF; }

      td.heading { background: #DDDDDD; }

      li                       { list-style-type: lower-roman; }
      li       ul li.obj       { display: none; }
      li:hover ul li.obj       { display: list-item; list-style-type: decimal; }
      li:hover ul li.obj:hover { display: list-item; list-style-type: square; }
    </style>

  </head>
  <body>
<table width="100%"><tr><td bgcolor="#DDFFDD"><h1>Vstr documentation -- constants</h1>
</td></tr></table><table width="90%"><tr><td>
<h3>Index of sections</h3>
<ul>
<li><a href="#Compile%20switch%20constants">Compile switch constants</a>
<ul>
<li class="obj"><a href="#VSTR_COMPILE_ATTRIBUTES">VSTR_COMPILE_ATTRIBUTES</a>
<li class="obj"><a href="#VSTR_COMPILE_INCLUDE">VSTR_COMPILE_INCLUDE</a>
<li class="obj"><a href="#VSTR_COMPILE_INLINE">VSTR_COMPILE_INLINE</a>
<li class="obj"><a href="#VSTR_COMPILE_MACRO_FUNCTIONS">VSTR_COMPILE_MACRO_FUNCTIONS</a>
<li class="obj"><a href="#VSTR_COMPILE_TYPEDEF">VSTR_COMPILE_TYPEDEF</a>
</ul><li><a href="#Global%20constants">Global constants</a>
<ul>
<li class="obj"><a href="#VSTR_MAX_NODE_ALL">VSTR_MAX_NODE_ALL</a>
<li class="obj"><a href="#VSTR_MAX_NODE_BUF">VSTR_MAX_NODE_BUF</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_make_spare_nodes%28%29%20and%20vstr_free_spare_nodes%28%29">Constants passed to vstr_make_spare_nodes() and vstr_free_spare_nodes()</a>
<ul>
<li class="obj"><a href="#VSTR_TYPE_NODE_BUF">VSTR_TYPE_NODE_BUF</a>
<li class="obj"><a href="#VSTR_TYPE_NODE_NON">VSTR_TYPE_NODE_NON</a>
<li class="obj"><a href="#VSTR_TYPE_NODE_PTR">VSTR_TYPE_NODE_PTR</a>
<li class="obj"><a href="#VSTR_TYPE_NODE_REF">VSTR_TYPE_NODE_REF</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_add_vstr%28%29%20and%20vstr_sub_vstr%28%29">Constants passed to vstr_add_vstr() and vstr_sub_vstr()</a>
<ul>
<li class="obj"><a href="#VSTR_TYPE_ADD_DEF">VSTR_TYPE_ADD_DEF</a>
<li class="obj"><a href="#VSTR_TYPE_SUB_DEF">VSTR_TYPE_SUB_DEF</a>
<li class="obj"><a href="#VSTR_TYPE_ADD_BUF_PTR">VSTR_TYPE_ADD_BUF_PTR</a>
<li class="obj"><a href="#VSTR_TYPE_SUB_BUF_PTR">VSTR_TYPE_SUB_BUF_PTR</a>
<li class="obj"><a href="#VSTR_TYPE_ADD_BUF_REF">VSTR_TYPE_ADD_BUF_REF</a>
<li class="obj"><a href="#VSTR_TYPE_SUB_BUF_REF">VSTR_TYPE_SUB_BUF_REF</a>
<li class="obj"><a href="#VSTR_TYPE_ADD_ALL_REF">VSTR_TYPE_ADD_ALL_REF</a>
<li class="obj"><a href="#VSTR_TYPE_SUB_ALL_REF">VSTR_TYPE_SUB_ALL_REF</a>
<li class="obj"><a href="#VSTR_TYPE_ADD_ALL_BUF">VSTR_TYPE_ADD_ALL_BUF</a>
<li class="obj"><a href="#VSTR_TYPE_SUB_ALL_BUF">VSTR_TYPE_SUB_ALL_BUF</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_fmt_add%28%29">Constants passed to vstr_fmt_add()</a>
<ul>
<li class="obj"><a href="#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_INT">VSTR_TYPE_FMT_INT</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_UINT">VSTR_TYPE_FMT_UINT</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_LONG">VSTR_TYPE_FMT_LONG</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_ULONG">VSTR_TYPE_FMT_ULONG</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_LONG_LONG">VSTR_TYPE_FMT_LONG_LONG</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_ULONG_LONG">VSTR_TYPE_FMT_ULONG_LONG</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_SSIZE_T">VSTR_TYPE_FMT_SSIZE_T</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_SIZE_T">VSTR_TYPE_FMT_SIZE_T</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_PTRDIFF_T">VSTR_TYPE_FMT_PTRDIFF_T</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_INTMAX_T">VSTR_TYPE_FMT_INTMAX_T</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_UINTMAX_T">VSTR_TYPE_FMT_UINTMAX_T</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_DOUBLE">VSTR_TYPE_FMT_DOUBLE</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_DOUBLE_LONG">VSTR_TYPE_FMT_DOUBLE_LONG</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_PTR_VOID">VSTR_TYPE_FMT_PTR_VOID</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_PTR_CHAR">VSTR_TYPE_FMT_PTR_CHAR</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_PTR_WCHAR_T">VSTR_TYPE_FMT_PTR_WCHAR_T</a>
<li class="obj"><a href="#VSTR_TYPE_FMT_ERRNO">VSTR_TYPE_FMT_ERRNO</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_sc_fmt_cb_beg%28%29">Constants passed to vstr_sc_fmt_cb_beg()</a>
<ul>
<li class="obj"><a href="#VSTR_FLAG_SC_FMT_CB_BEG_DEF">VSTR_FLAG_SC_FMT_CB_BEG_DEF</a>
<li class="obj"><a href="#VSTR_FLAG_SC_FMT_CB_BEG_OBJ_STR">VSTR_FLAG_SC_FMT_CB_BEG_OBJ_STR</a>
<li class="obj"><a href="#VSTR_FLAG_SC_FMT_CB_BEG_OBJ_ATOM">VSTR_FLAG_SC_FMT_CB_BEG_OBJ_ATOM</a>
<li class="obj"><a href="#VSTR_FLAG_SC_FMT_CB_BEG_OBJ_NUM">VSTR_FLAG_SC_FMT_CB_BEG_OBJ_NUM</a>
<li class="obj"><a href="#VSTR_FLAG_SC_FMT_CB_BEG_OBJ_NEG">VSTR_FLAG_SC_FMT_CB_BEG_OBJ_NEG</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_conv_unprintable_del%28%29%20and%20vstr_conv_unprintable_chr%28%29">Constants passed to vstr_conv_unprintable_del() and vstr_conv_unprintable_chr()</a>
<ul>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_NONE">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_NONE</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_NUL">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_NUL</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_BEL">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_BEL</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_BS">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_BS</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HT">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HT</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_LF">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_LF</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_VT">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_VT</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_FF">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_FF</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_CR">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_CR</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_SP">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_SP</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_COMMA">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_COMMA</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_DOT">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_DOT</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW__">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW__</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_ESC">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_ESC</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_DEL">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_DEL</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HSP">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HSP</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HIGH">VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HIGH</a>
<li class="obj"><a href="#VSTR_FLAG_CONV_UNPRINTABLE_DEF">VSTR_FLAG_CONV_UNPRINTABLE_DEF</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_parse_%5bu%5d%28short%7cint%7clong%7cintmax%29%28%29">Constants passed to vstr_parse_[u](short|int|long|intmax)()</a>
<ul>
<li class="obj"><a href="#VSTR_TYPE_PARSE_NUM_ERR_NONE">VSTR_TYPE_PARSE_NUM_ERR_NONE</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_NUM_ERR_ONLY_S">VSTR_TYPE_PARSE_NUM_ERR_ONLY_S</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_NUM_ERR_ONLY_SPM">VSTR_TYPE_PARSE_NUM_ERR_ONLY_SPM</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_NUM_ERR_ONLY_SPMX">VSTR_TYPE_PARSE_NUM_ERR_ONLY_SPMX</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_NUM_ERR_OOB">VSTR_TYPE_PARSE_NUM_ERR_OOB</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_NUM_ERR_OVERFLOW">VSTR_TYPE_PARSE_NUM_ERR_OVERFLOW</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_NUM_ERR_NEGATIVE">VSTR_TYPE_PARSE_NUM_ERR_NEGATIVE</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_NUM_ERR_BEG_ZERO">VSTR_TYPE_PARSE_NUM_ERR_BEG_ZERO</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_NUM_DEF">VSTR_FLAG_PARSE_NUM_DEF</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_NUM_LOCAL">VSTR_FLAG_PARSE_NUM_LOCAL</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_NUM_SEP">VSTR_FLAG_PARSE_NUM_SEP</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_NUM_OVERFLOW">VSTR_FLAG_PARSE_NUM_OVERFLOW</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_NUM_SPACE">VSTR_FLAG_PARSE_NUM_SPACE</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_NUM_NO_BEG_ZERO">VSTR_FLAG_PARSE_NUM_NO_BEG_ZERO</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_NUM_NO_BEG_PM">VSTR_FLAG_PARSE_NUM_NO_BEG_PM</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_parse_ipv4%28%29">Constants passed to vstr_parse_ipv4()</a>
<ul>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV4_ERR_NONE">VSTR_TYPE_PARSE_IPV4_ERR_NONE</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV4_ERR_IPV4_OOB">VSTR_TYPE_PARSE_IPV4_ERR_IPV4_OOB</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV4_ERR_IPV4_FULL">VSTR_TYPE_PARSE_IPV4_ERR_IPV4_FULL</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV4_ERR_ONLY">VSTR_TYPE_PARSE_IPV4_ERR_ONLY</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV4_ERR_CIDR_OOB">VSTR_TYPE_PARSE_IPV4_ERR_CIDR_OOB</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV4_ERR_CIDR_FULL">VSTR_TYPE_PARSE_IPV4_ERR_CIDR_FULL</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV4_ERR_NETMASK_OOB">VSTR_TYPE_PARSE_IPV4_ERR_NETMASK_OOB</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV4_ERR_NETMASK_FULL">VSTR_TYPE_PARSE_IPV4_ERR_NETMASK_FULL</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV4_DEF">VSTR_FLAG_PARSE_IPV4_DEF</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV4_LOCAL">VSTR_FLAG_PARSE_IPV4_LOCAL</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV4_ZEROS">VSTR_FLAG_PARSE_IPV4_ZEROS</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV4_FULL">VSTR_FLAG_PARSE_IPV4_FULL</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV4_CIDR">VSTR_FLAG_PARSE_IPV4_CIDR</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV4_CIDR_FULL">VSTR_FLAG_PARSE_IPV4_CIDR_FULL</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV4_NETMASK">VSTR_FLAG_PARSE_IPV4_NETMASK</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV4_NETMASK_FULL">VSTR_FLAG_PARSE_IPV4_NETMASK_FULL</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV4_ONLY">VSTR_FLAG_PARSE_IPV4_ONLY</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_parse_ipv6%28%29">Constants passed to vstr_parse_ipv6()</a>
<ul>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV6_ERR_NONE">VSTR_TYPE_PARSE_IPV6_ERR_NONE</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV6_ERR_IPV6_OOB">VSTR_TYPE_PARSE_IPV6_ERR_IPV6_OOB</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV6_ERR_IPV6_FULL">VSTR_TYPE_PARSE_IPV6_ERR_IPV6_FULL</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV6_ERR_ONLY">VSTR_TYPE_PARSE_IPV6_ERR_ONLY</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV6_ERR_CIDR_OOB">VSTR_TYPE_PARSE_IPV6_ERR_CIDR_OOB</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV6_ERR_CIDR_FULL">VSTR_TYPE_PARSE_IPV6_ERR_CIDR_FULL</a>
<li class="obj"><a href="#VSTR_TYPE_PARSE_IPV6_ERR_IPV6_NULL">VSTR_TYPE_PARSE_IPV6_ERR_IPV6_NULL</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV6_DEF">VSTR_FLAG_PARSE_IPV6_DEF</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV6_LOCAL">VSTR_FLAG_PARSE_IPV6_LOCAL</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV6_CIDR">VSTR_FLAG_PARSE_IPV6_CIDR</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV6_CIDR_FULL">VSTR_FLAG_PARSE_IPV6_CIDR_FULL</a>
<li class="obj"><a href="#VSTR_FLAG_PARSE_IPV6_ONLY">VSTR_FLAG_PARSE_IPV6_ONLY</a>
</ul><li><a href="#Constants%20used%20with%20the%20custom%20output%20formatter%20for%20ipv6%20addresses">Constants used with the custom output formatter for ipv6 addresses</a>
<ul>
<li class="obj"><a href="#VSTR_TYPE_SC_FMT_CB_IPV6_ALIGNED">VSTR_TYPE_SC_FMT_CB_IPV6_ALIGNED</a>
<li class="obj"><a href="#VSTR_TYPE_SC_FMT_CB_IPV6_COMPACT">VSTR_TYPE_SC_FMT_CB_IPV6_COMPACT</a>
<li class="obj"><a href="#VSTR_TYPE_SC_FMT_CB_IPV6_STD">VSTR_TYPE_SC_FMT_CB_IPV6_STD</a>
<li class="obj"><a href="#VSTR_TYPE_SC_FMT_CB_IPV6_IPV4_ALIGNED">VSTR_TYPE_SC_FMT_CB_IPV6_IPV4_ALIGNED</a>
<li class="obj"><a href="#VSTR_TYPE_SC_FMT_CB_IPV6_IPV4_COMPACT">VSTR_TYPE_SC_FMT_CB_IPV6_IPV4_COMPACT</a>
<li class="obj"><a href="#VSTR_TYPE_SC_FMT_CB_IPV6_IPV4_STD">VSTR_TYPE_SC_FMT_CB_IPV6_IPV4_STD</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_split_buf%28%29%2c%20vstr_split_cstr_buf%28%29%2c%20VSTR_SPLIT_CSTR_BUF%28%29%2c%20vstr_split_chrs%28%29%2c%20vstr_split_cstr_chrs%28%29%20and%20VSTR_SPLIT_CSTR_CHRS%28%29">Constants passed to vstr_split_buf(), vstr_split_cstr_buf(), VSTR_SPLIT_CSTR_BUF(), vstr_split_chrs(), vstr_split_cstr_chrs() and VSTR_SPLIT_CSTR_CHRS()</a>
<ul>
<li class="obj"><a href="#VSTR_FLAG_SPLIT_DEF">VSTR_FLAG_SPLIT_DEF</a>
<li class="obj"><a href="#VSTR_FLAG_SPLIT_BEG_NULL">VSTR_FLAG_SPLIT_BEG_NULL</a>
<li class="obj"><a href="#VSTR_FLAG_SPLIT_MID_NULL">VSTR_FLAG_SPLIT_MID_NULL</a>
<li class="obj"><a href="#VSTR_FLAG_SPLIT_END_NULL">VSTR_FLAG_SPLIT_END_NULL</a>
<li class="obj"><a href="#VSTR_FLAG_SPLIT_POST_NULL">VSTR_FLAG_SPLIT_POST_NULL</a>
<li class="obj"><a href="#VSTR_FLAG_SPLIT_NO_RET">VSTR_FLAG_SPLIT_NO_RET</a>
<li class="obj"><a href="#VSTR_FLAG_SPLIT_REMAIN">VSTR_FLAG_SPLIT_REMAIN</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_sects_foreach%28%29">Constants passed to vstr_sects_foreach()</a>
<ul>
<li class="obj"><a href="#VSTR_FLAG_SECTS_FOREACH_DEF">VSTR_FLAG_SECTS_FOREACH_DEF</a>
<li class="obj"><a href="#VSTR_FLAG_SECTS_FOREACH_BACKWARD">VSTR_FLAG_SECTS_FOREACH_BACKWARD</a>
<li class="obj"><a href="#VSTR_FLAG_SECTS_FOREACH_ALLOW_NULL">VSTR_FLAG_SECTS_FOREACH_ALLOW_NULL</a>
<li class="obj"><a href="#VSTR_TYPE_SECTS_FOREACH_DEF">VSTR_TYPE_SECTS_FOREACH_DEF</a>
<li class="obj"><a href="#VSTR_TYPE_SECTS_FOREACH_DEL">VSTR_TYPE_SECTS_FOREACH_DEL</a>
<li class="obj"><a href="#VSTR_TYPE_SECTS_FOREACH_RET">VSTR_TYPE_SECTS_FOREACH_RET</a>
</ul><li><a href="#Constants%20used%20with%20the%20callback%20from%20vstr_cache_add_cb%28%29">Constants used with the callback from vstr_cache_add_cb()</a>
<ul>
<li class="obj"><a href="#VSTR_TYPE_CACHE_ADD">VSTR_TYPE_CACHE_ADD</a>
<li class="obj"><a href="#VSTR_TYPE_CACHE_DEL">VSTR_TYPE_CACHE_DEL</a>
<li class="obj"><a href="#VSTR_TYPE_CACHE_SUB">VSTR_TYPE_CACHE_SUB</a>
<li class="obj"><a href="#VSTR_TYPE_CACHE_FREE">VSTR_TYPE_CACHE_FREE</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_sc_mmap_fd%28%29%20and%20vstr_sc_mmap_file%28%29">Constants passed to vstr_sc_mmap_fd() and vstr_sc_mmap_file()</a>
<ul>
<li class="obj"><a href="#VSTR_TYPE_SC_MMAP_FD_ERR_NONE">VSTR_TYPE_SC_MMAP_FD_ERR_NONE</a>
<li class="obj"><a href="#VSTR_TYPE_SC_MMAP_FILE_ERR_NONE">VSTR_TYPE_SC_MMAP_FILE_ERR_NONE</a>
<li class="obj"><a href="#VSTR_TYPE_SC_MMAP_FILE_ERR_OPEN_ERRNO">VSTR_TYPE_SC_MMAP_FILE_ERR_OPEN_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_MMAP_FD_ERR_FSTAT_ERRNO">VSTR_TYPE_SC_MMAP_FD_ERR_FSTAT_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_MMAP_FILE_ERR_FSTAT_ERRNO">VSTR_TYPE_SC_MMAP_FILE_ERR_FSTAT_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_MMAP_FD_ERR_MMAP_ERRNO">VSTR_TYPE_SC_MMAP_FD_ERR_MMAP_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_MMAP_FILE_ERR_MMAP_ERRNO">VSTR_TYPE_SC_MMAP_FILE_ERR_MMAP_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_MMAP_FILE_ERR_CLOSE_ERRNO">VSTR_TYPE_SC_MMAP_FILE_ERR_CLOSE_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_MMAP_FD_ERR_MEM">VSTR_TYPE_SC_MMAP_FD_ERR_MEM</a>
<li class="obj"><a href="#VSTR_TYPE_SC_MMAP_FILE_ERR_MEM">VSTR_TYPE_SC_MMAP_FILE_ERR_MEM</a>
<li class="obj"><a href="#VSTR_TYPE_SC_MMAP_FD_ERR_TOO_LARGE">VSTR_TYPE_SC_MMAP_FD_ERR_TOO_LARGE</a>
<li class="obj"><a href="#VSTR_TYPE_SC_MMAP_FILE_ERR_TOO_LARGE">VSTR_TYPE_SC_MMAP_FILE_ERR_TOO_LARGE</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_sc_read_iov_fd%28%29%2c%20vstr_sc_read_len_fd%28%29%2c%20vstr_sc_read_iov_file%28%29%20and%20vstr_sc_read_len_file%28%29">Constants passed to vstr_sc_read_iov_fd(), vstr_sc_read_len_fd(), vstr_sc_read_iov_file() and vstr_sc_read_len_file()</a>
<ul>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FD_ERR_NONE">VSTR_TYPE_SC_READ_FD_ERR_NONE</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FILE_ERR_NONE">VSTR_TYPE_SC_READ_FILE_ERR_NONE</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FILE_ERR_OPEN_ERRNO">VSTR_TYPE_SC_READ_FILE_ERR_OPEN_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FD_ERR_FSTAT_ERRNO">VSTR_TYPE_SC_READ_FD_ERR_FSTAT_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FILE_ERR_FSTAT_ERRNO">VSTR_TYPE_SC_READ_FILE_ERR_FSTAT_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FILE_ERR_SEEK_ERRNO">VSTR_TYPE_SC_READ_FILE_ERR_SEEK_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FD_ERR_READ_ERRNO">VSTR_TYPE_SC_READ_FD_ERR_READ_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FILE_ERR_READ_ERRNO">VSTR_TYPE_SC_READ_FILE_ERR_READ_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FILE_ERR_CLOSE_ERRNO">VSTR_TYPE_SC_READ_FILE_ERR_CLOSE_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FD_ERR_EOF">VSTR_TYPE_SC_READ_FD_ERR_EOF</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FILE_ERR_EOF">VSTR_TYPE_SC_READ_FILE_ERR_EOF</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FD_ERR_MEM">VSTR_TYPE_SC_READ_FD_ERR_MEM</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FILE_ERR_MEM">VSTR_TYPE_SC_READ_FILE_ERR_MEM</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FD_ERR_TOO_LARGE">VSTR_TYPE_SC_READ_FD_ERR_TOO_LARGE</a>
<li class="obj"><a href="#VSTR_TYPE_SC_READ_FILE_ERR_TOO_LARGE">VSTR_TYPE_SC_READ_FILE_ERR_TOO_LARGE</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_sc_write_fd%28%29%20and%20vstr_sc_write_file%28%29">Constants passed to vstr_sc_write_fd() and vstr_sc_write_file()</a>
<ul>
<li class="obj"><a href="#VSTR_TYPE_SC_WRITE_FD_ERR_NONE">VSTR_TYPE_SC_WRITE_FD_ERR_NONE</a>
<li class="obj"><a href="#VSTR_TYPE_SC_WRITE_FILE_ERR_NONE">VSTR_TYPE_SC_WRITE_FILE_ERR_NONE</a>
<li class="obj"><a href="#VSTR_TYPE_SC_WRITE_FILE_ERR_SEEK_ERRNO">VSTR_TYPE_SC_WRITE_FILE_ERR_SEEK_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_WRITE_FILE_ERR_OPEN_ERRNO">VSTR_TYPE_SC_WRITE_FILE_ERR_OPEN_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_WRITE_FD_ERR_WRITE_ERRNO">VSTR_TYPE_SC_WRITE_FD_ERR_WRITE_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_WRITE_FILE_ERR_WRITE_ERRNO">VSTR_TYPE_SC_WRITE_FILE_ERR_WRITE_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_WRITE_FILE_ERR_CLOSE_ERRNO">VSTR_TYPE_SC_WRITE_FILE_ERR_CLOSE_ERRNO</a>
<li class="obj"><a href="#VSTR_TYPE_SC_WRITE_FD_ERR_MEM">VSTR_TYPE_SC_WRITE_FD_ERR_MEM</a>
<li class="obj"><a href="#VSTR_TYPE_SC_WRITE_FILE_ERR_MEM">VSTR_TYPE_SC_WRITE_FILE_ERR_MEM</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_cntl_base%28%29">Constants passed to vstr_cntl_base()</a>
<ul>
<li class="obj"><a href="#VSTR_CNTL_BASE_GET_CONF">VSTR_CNTL_BASE_GET_CONF</a>
<li class="obj"><a href="#VSTR_CNTL_BASE_SET_CONF">VSTR_CNTL_BASE_SET_CONF</a>
<li class="obj"><a href="#VSTR_CNTL_BASE_GET_FLAG_HAVE_CACHE">VSTR_CNTL_BASE_GET_FLAG_HAVE_CACHE</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_cntl_conf%28%29">Constants passed to vstr_cntl_conf()</a>
<ul>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_NUM_BUF_SZ">VSTR_CNTL_CONF_GET_NUM_BUF_SZ</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_NUM_BUF_SZ">VSTR_CNTL_CONF_SET_NUM_BUF_SZ</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_NUM_IOV_MIN_ALLOC">VSTR_CNTL_CONF_GET_NUM_IOV_MIN_ALLOC</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_NUM_IOV_MIN_ALLOC">VSTR_CNTL_CONF_SET_NUM_IOV_MIN_ALLOC</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_NUM_IOV_MIN_OFFSET">VSTR_CNTL_CONF_GET_NUM_IOV_MIN_OFFSET</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_NUM_IOV_MIN_OFFSET">VSTR_CNTL_CONF_SET_NUM_IOV_MIN_OFFSET</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_NUM_REF">VSTR_CNTL_CONF_GET_NUM_REF</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_LOC_CSTR_AUTO_NAME_NUMERIC">VSTR_CNTL_CONF_SET_LOC_CSTR_AUTO_NAME_NUMERIC</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_LOC_CSTR_NAME_NUMERIC">VSTR_CNTL_CONF_GET_LOC_CSTR_NAME_NUMERIC</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_LOC_CSTR_NAME_NUMERIC">VSTR_CNTL_CONF_SET_LOC_CSTR_NAME_NUMERIC</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_LOC_CSTR_DEC_POINT">VSTR_CNTL_CONF_GET_LOC_CSTR_DEC_POINT</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_LOC_CSTR_DEC_POINT">VSTR_CNTL_CONF_SET_LOC_CSTR_DEC_POINT</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_LOC_CSTR_THOU_SEP">VSTR_CNTL_CONF_GET_LOC_CSTR_THOU_SEP</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_LOC_CSTR_THOU_SEP">VSTR_CNTL_CONF_SET_LOC_CSTR_THOU_SEP</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_LOC_CSTR_THOU_GRP">VSTR_CNTL_CONF_GET_LOC_CSTR_THOU_GRP</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_LOC_CSTR_THOU_GRP">VSTR_CNTL_CONF_SET_LOC_CSTR_THOU_GRP</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_FLAG_IOV_UPDATE">VSTR_CNTL_CONF_GET_FLAG_IOV_UPDATE</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_FLAG_IOV_UPDATE">VSTR_CNTL_CONF_SET_FLAG_IOV_UPDATE</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_FLAG_DEL_SPLIT">VSTR_CNTL_CONF_GET_FLAG_DEL_SPLIT</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_FLAG_DEL_SPLIT">VSTR_CNTL_CONF_SET_FLAG_DEL_SPLIT</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_FLAG_ALLOC_CACHE">VSTR_CNTL_CONF_GET_FLAG_ALLOC_CACHE</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_FLAG_ALLOC_CACHE">VSTR_CNTL_CONF_SET_FLAG_ALLOC_CACHE</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_FMT_CHAR_ESC">VSTR_CNTL_CONF_GET_FMT_CHAR_ESC</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_FMT_CHAR_ESC">VSTR_CNTL_CONF_SET_FMT_CHAR_ESC</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_NUM_SPARE_BUF">VSTR_CNTL_CONF_GET_NUM_SPARE_BUF</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_NUM_SPARE_NON">VSTR_CNTL_CONF_GET_NUM_SPARE_NON</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_NUM_SPARE_PTR">VSTR_CNTL_CONF_GET_NUM_SPARE_PTR</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_NUM_SPARE_REF">VSTR_CNTL_CONF_GET_NUM_SPARE_REF</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_NUM_SPARE_BUF">VSTR_CNTL_CONF_SET_NUM_SPARE_BUF</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_NUM_SPARE_NON">VSTR_CNTL_CONF_SET_NUM_SPARE_NON</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_NUM_SPARE_PTR">VSTR_CNTL_CONF_SET_NUM_SPARE_PTR</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_NUM_SPARE_REF">VSTR_CNTL_CONF_SET_NUM_SPARE_REF</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_GET_FLAG_ATOMIC_OPS">VSTR_CNTL_CONF_GET_FLAG_ATOMIC_OPS</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_FLAG_ATOMIC_OPS">VSTR_CNTL_CONF_SET_FLAG_ATOMIC_OPS</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_BUF">VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_BUF</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_NON">VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_NON</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_PTR">VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_PTR</a>
<li class="obj"><a href="#VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_REF">VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_REF</a>
</ul><li><a href="#Constants%20passed%20to%20vstr_cntl_opt%28%29">Constants passed to vstr_cntl_opt()</a>
<ul>
<li class="obj"><a href="#VSTR_CNTL_OPT_GET_CONF">VSTR_CNTL_OPT_GET_CONF</a>
<li class="obj"><a href="#VSTR_CNTL_OPT_SET_CONF">VSTR_CNTL_OPT_SET_CONF</a>
</ul></ul>
</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Compile%20switch%20constants"><h2>Compile switch constants</h2>
</a>
<a name="VSTR_COMPILE_ATTRIBUTES"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_COMPILE_ATTRIBUTES
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This switch controls whether gcc type __attribute__() statements are used in
 the public headers headers for the library. If the value is 1 then if they are
 supported by the compiler that built the library they will be used, if the
 value is 0 they won't be used at all.


<a name="VSTR_COMPILE_INCLUDE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_COMPILE_INCLUDE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This switch controls whether including &lt;vstr.h&gt; will include all the system
 headers needed for the exported interfaces. If the value is 1 then if they are
 included, if the value is 0 they won't be included.


<a name="VSTR_COMPILE_INLINE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_COMPILE_INLINE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This switch controls whether inline functions will be used in the public
 headers for the library. If the value is 1 then if they are supported by the
 compiler that built the library they will be used, if the value is 0 they
 won't be used.


<a name="VSTR_COMPILE_MACRO_FUNCTIONS"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_COMPILE_MACRO_FUNCTIONS
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This switch controls whether macro functions will be used in the public
 headers for the library. If the value is 1 then they will be used, if the
 value is 0 they won't be used.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This only includes the macro  functions which also have real function
 replacements. For example <a href="functions.html#VSTR_ADD_CSTR_BUF()">VSTR_ADD_CSTR_BUF()</a> won't be defined because there
 is a <a href="functions.html#vstr_add_cstr_buf()">vstr_add_cstr_buf()</a> function, but <a href="functions.html#VSTR_FMT_CB_ARG_PTR()">VSTR_FMT_CB_ARG_PTR()</a> will always be
 defined.


<a name="VSTR_COMPILE_TYPEDEF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_COMPILE_TYPEDEF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This switch controls whether typedef will be used for the structs in the
 public headers for the library. If the value is 1 then they will be used,
 if the value is 0 they won't be used at all (and your code will have to use
 struct tags instead -- note all libraries using vstr should compile with
 this option set).


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Global%20constants"><h2>Global constants</h2>
</a>
<a name="VSTR_MAX_NODE_ALL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_MAX_NODE_ALL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This is the largest size a node can be, if you pass values greater than this
 to <a href="functions.html#vstr_add_ptr()">vstr_add_ptr()</a> etc. then multiple nodes will be allocated.


<a name="VSTR_MAX_NODE_BUF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_MAX_NODE_BUF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This is the largest size a node _BUF type can be, if you pass values greater
 than this to <a href="functions.html#vstr_add_buf()">vstr_add_buf()</a> etc. then multiple nodes will be allocated.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_make_spare_nodes%28%29%20and%20vstr_free_spare_nodes%28%29"><h2>Constants passed to
			 	<a name="vstr_make_spare_nodes()"><a href="functions.html#vstr_make_spare_nodes()">vstr_make_spare_nodes()</a></a>

		       and
			 	<a name="vstr_free_spare_nodes()"><a href="functions.html#vstr_free_spare_nodes()">vstr_free_spare_nodes()</a></a>

		      </h2>
</a>
<a name="VSTR_TYPE_NODE_BUF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_NODE_BUF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type when passed to <a href="functions.html#vstr_make_space_nodes()">vstr_make_space_nodes()</a> specifies nodes of type _BUF,
 which are the only nodes that can be "written" to. These nodes are added into
 a Vstr string by the <a href="functions.html#vstr_add_buf()">vstr_add_buf()</a> function and the vstr_add_iovec_buf_*()
 functions.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  A call to <a href="functions.html#vstr_sub_buf()">vstr_sub_buf()</a> with a Vstr string consisting of _BUF nodes means
 that data will be substituted inplace.


<a name="VSTR_TYPE_NODE_NON"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_NODE_NON
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type when passed to <a href="functions.html#vstr_make_space_nodes()">vstr_make_space_nodes()</a> specifies nodes of type _NON,
 which are nodes that contain "nothing". These nodes can be used as placeholders
 for data, and are added into a Vstr string by the <a href="functions.html#vstr_add_non()">vstr_add_non()</a> function.


<a name="VSTR_TYPE_NODE_PTR"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_NODE_PTR
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type when passed to <a href="functions.html#vstr_make_space_nodes()">vstr_make_space_nodes()</a> specifies nodes of type _PTR,
 which are nodes that contain a memory pointer to an area of memory.


<a name="VSTR_TYPE_NODE_REF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_NODE_REF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type when passed to <a href="functions.html#vstr_make_space_nodes()">vstr_make_space_nodes()</a> specifies nodes of type _REF,
 which are nodes that contain a Vstr memory reference.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_add_vstr%28%29%20and%20vstr_sub_vstr%28%29"><h2>Constants passed to
			 	<a name="vstr_add_vstr()"><a href="functions.html#vstr_add_vstr()">vstr_add_vstr()</a></a>

		       and
			 	<a name="vstr_sub_vstr()"><a href="functions.html#vstr_sub_vstr()">vstr_sub_vstr()</a></a>

		      </h2>
</a>
<a name="VSTR_TYPE_ADD_DEF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_ADD_DEF
</a><a name="VSTR_TYPE_SUB_DEF"><br><strong>Constant: </strong> VSTR_TYPE_SUB_DEF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type when passed to either <a href="functions.html#vstr_sub_vstr()">vstr_sub_vstr()</a> or <a href="functions.html#vstr_add_vstr()">vstr_add_vstr()</a> specifies
 that all types of nodes are added as their respective type.


<a name="VSTR_TYPE_ADD_BUF_PTR"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_ADD_BUF_PTR
</a><a name="VSTR_TYPE_SUB_BUF_PTR"><br><strong>Constant: </strong> VSTR_TYPE_SUB_BUF_PTR
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type when passed to either <a href="functions.html#vstr_sub_vstr()">vstr_sub_vstr()</a> or <a href="functions.html#vstr_add_vstr()">vstr_add_vstr()</a> specifies
 that all nodes of type _BUF are added as type _PTR.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If you add/del/sub data in the original Vstr string then because the added
 data is only pointers to the old data, life may become interesting for you.


<a name="VSTR_TYPE_ADD_BUF_REF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_ADD_BUF_REF
</a><a name="VSTR_TYPE_SUB_BUF_REF"><br><strong>Constant: </strong> VSTR_TYPE_SUB_BUF_REF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type when passed to either <a href="functions.html#vstr_sub_vstr()">vstr_sub_vstr()</a> or <a href="functions.html#vstr_add_vstr()">vstr_add_vstr()</a> specifies
 that all nodes of type _BUF are converted to type _REF before being added.


</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This means that if you do a substitution on the original Vstr string it will
 now be less efficient, as the _REF nodes cannot have data substituted in place.
</p><p>  The _BUF nodes will not go back to the pool in the Vstr configuration as
 happens if you deleted them.


<a name="VSTR_TYPE_ADD_ALL_REF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_ADD_ALL_REF
</a><a name="VSTR_TYPE_SUB_ALL_REF"><br><strong>Constant: </strong> VSTR_TYPE_SUB_ALL_REF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type when passed to either <a href="functions.html#vstr_sub_vstr()">vstr_sub_vstr()</a> or <a href="functions.html#vstr_add_vstr()">vstr_add_vstr()</a> specifies
 that the data should be taken as though <a href="functions.html#vstr_export_ref()">vstr_export_ref()</a> was called on the
 original Vstr string.


<a name="VSTR_TYPE_ADD_ALL_BUF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_ADD_ALL_BUF
</a><a name="VSTR_TYPE_SUB_ALL_BUF"><br><strong>Constant: </strong> VSTR_TYPE_SUB_ALL_BUF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type when passed to either <a href="functions.html#vstr_sub_vstr()">vstr_sub_vstr()</a> or <a href="functions.html#vstr_add_vstr()">vstr_add_vstr()</a> specifies
 that the data should all be added via. <a href="functions.html#vstr_add_buf()">vstr_add_buf()</a>.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_fmt_add%28%29"><h2>Constants passed to
			 	<a name="vstr_fmt_add()"><a href="functions.html#vstr_fmt_add()">vstr_fmt_add()</a></a>

		      </h2>
</a>
<a name="VSTR_TYPE_FMT_END"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_END
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that there are no more arguments to be expected.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Because you can have multiple arguments associated with one custom &quot;fmt&quot; 
 specification this has to be the last argument to every call to
 <a href="functions.html#vstr_fmt_add()">vstr_fmt_add()</a>.
</p><p>  Just specifying this type means that there are no arguments used, by the
 custom "fmt" specification.


<a name="VSTR_TYPE_FMT_INT"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_INT
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;int&quot; type from
 the argument list passed to it


<a name="VSTR_TYPE_FMT_UINT"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_UINT
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect an &quot;unsigned int&quot; type from
 the argument list passed to it


<a name="VSTR_TYPE_FMT_LONG"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_LONG
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;long&quot; type from
 the argument list passed to it


<a name="VSTR_TYPE_FMT_ULONG"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_ULONG
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect an &quot;unsigned long&quot; type
 from the argument list passed to it


<a name="VSTR_TYPE_FMT_LONG_LONG"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_LONG_LONG
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;long long&quot; type from
 the argument list passed to it


<a name="VSTR_TYPE_FMT_ULONG_LONG"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_ULONG_LONG
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect an &quot;unsigned long long&quot;
 type from the argument list passed to it


<a name="VSTR_TYPE_FMT_SSIZE_T"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_SSIZE_T
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;ssize_t&quot; type
 from the argument list passed to it


<a name="VSTR_TYPE_FMT_SIZE_T"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_SIZE_T
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;size_t&quot; type
 from the argument list passed to it


<a name="VSTR_TYPE_FMT_PTRDIFF_T"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_PTRDIFF_T
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;ptrdiff_t&quot; type
 from the argument list passed to it


<a name="VSTR_TYPE_FMT_INTMAX_T"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_INTMAX_T
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;intmax_t&quot; type
 from the argument list passed to it


<a name="VSTR_TYPE_FMT_UINTMAX_T"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_UINTMAX_T
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;uintmax_t&quot; type
 from the argument list passed to it


<a name="VSTR_TYPE_FMT_DOUBLE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_DOUBLE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;double&quot; type
 from the argument list passed to it


<a name="VSTR_TYPE_FMT_DOUBLE_LONG"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_DOUBLE_LONG
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;long double&quot; type
 from the argument list passed to it


<a name="VSTR_TYPE_FMT_PTR_VOID"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_PTR_VOID
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;void *&quot; type
 from the argument list passed to it


<a name="VSTR_TYPE_FMT_PTR_CHAR"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_PTR_CHAR
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;char *&quot; type
 from the argument list passed to it


<a name="VSTR_TYPE_FMT_PTR_WCHAR_T"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_PTR_WCHAR_T
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should expect a &quot;wchar_t *&quot; type
 from the argument list passed to it


<a name="VSTR_TYPE_FMT_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_FMT_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag means that <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> should not expect any arguments passed,
 but should set the value of errno, just before calling the user callback, to
 the value upon entering <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a>.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_sc_fmt_cb_beg%28%29"><h2>Constants passed to
			 	<a name="vstr_sc_fmt_cb_beg()"><a href="functions.html#vstr_sc_fmt_cb_beg()">vstr_sc_fmt_cb_beg()</a></a>

		      </h2>
</a>
<a name="VSTR_FLAG_SC_FMT_CB_BEG_DEF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SC_FMT_CB_BEG_DEF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag is the same as just specifying <a href="constants.html#VSTR_FLAG_SC_FMT_CB_BEG_OBJ_STR">VSTR_FLAG_SC_FMT_CB_BEG_OBJ_STR</a>.


<a name="VSTR_FLAG_SC_FMT_CB_BEG_OBJ_STR"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SC_FMT_CB_BEG_OBJ_STR
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag indicates that the object should be treated as a C style string,
 so it is assumed that number orientated flags should be ignored and that
 the length of the object can be arbitrarily truncated.


<a name="VSTR_FLAG_SC_FMT_CB_BEG_OBJ_ATOM"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SC_FMT_CB_BEG_OBJ_ATOM
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag indicates that the object should be treated as an atomic piece of
 data, so it is assumed that number orientated flags should be ignored and
 that the length of the object can't be truncated.


<a name="VSTR_FLAG_SC_FMT_CB_BEG_OBJ_NUM"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SC_FMT_CB_BEG_OBJ_NUM
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag indicates that the object you are printing should be treated as a
 number. For instance setting a precision will truncate the length of the
 object, unless it is a number. Also +/-/<space> leaders and zero padding will
 only be done for numbers.


<a name="VSTR_FLAG_SC_FMT_CB_BEG_OBJ_NEG"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SC_FMT_CB_BEG_OBJ_NEG
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag indicates that the number object you are printing should be
 treated as negative number. This flag has no meaning if
 <a href="constants.html#VSTR_FLAG_SC_FMT_CB_BEG_OBJ_NUM">VSTR_FLAG_SC_FMT_CB_BEG_OBJ_NUM</a> is not set.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_conv_unprintable_del%28%29%20and%20vstr_conv_unprintable_chr%28%29"><h2>Constants passed to
			 	<a name="vstr_conv_unprintable_del()"><a href="functions.html#vstr_conv_unprintable_del()">vstr_conv_unprintable_del()</a></a>

		       and
			 	<a name="vstr_conv_unprintable_chr()"><a href="functions.html#vstr_conv_unprintable_chr()">vstr_conv_unprintable_chr()</a></a>

		      </h2>
</a>
<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_NONE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_NONE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag is 0, and is generally only used as programmer documentation to mean
 no flags are applied to this function.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Because it is sometimes hard are to notice certain characters, they are
 classified as "unprintable" by default, the value
 <a href="constants.html#VSTR_FLAG_CONV_UNPRINTABLE_DEF">VSTR_FLAG_CONV_UNPRINTABLE_DEF</a> is a default that is what most people would
 expect to be classified as unprintable.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_NUL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_NUL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x00 byte, aka. NULL, through as a &quot;printable&quot;
 character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_BEL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_BEL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x07 byte, aka. terminal bell, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_BS"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_BS
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x08 byte, aka. backspace, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HT"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HT
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x09 byte, aka. horizontal tab, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_LF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_LF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x0A byte, aka. line feed, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_VT"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_VT
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x0B byte, aka. vertical tab, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_FF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_FF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x0C byte, aka. form feed, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_CR"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_CR
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x0D byte, aka. carriage return, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_SP"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_SP
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x20 byte, aka. space, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_COMMA"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_COMMA
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x2C byte, aka. comma, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_DOT"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_DOT
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x2E byte, aka. dot, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW__"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW__
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x5F byte, aka. underbar, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_ESC"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_ESC
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x1B byte, aka. escape, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_DEL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_DEL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0x7F byte, aka. delete, through as a
 "printable" character.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HSP"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HSP
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the ASCII 0xA0 byte through as a &quot;printable&quot; character.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The value 0xA0 is 0x20 with the high bit set, and this character it often
 printed as space when in an ASCII like encoding.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HIGH"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HIGH
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the all ASCII bytes greater than or equal to 0xA1 through as
 "printable" characters.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This includes all the extra characters like not, degree, copyright and micro
 when in an ASCII like encoding.


<a name="VSTR_FLAG_CONV_UNPRINTABLE_DEF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_CONV_UNPRINTABLE_DEF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag is the same as using the flags for space, comma, dot and underbar.
 Using just this flag is probably what you'd expect an "unprintable" function
 to do.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_parse_%5bu%5d%28short%7cint%7clong%7cintmax%29%28%29"><h2>Constants passed to vstr_parse_[u](short|int|long|intmax)()</h2>
</a>
<a name="VSTR_TYPE_PARSE_NUM_ERR_NONE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_NUM_ERR_NONE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code has the value 0, and means that no error occurred parsing the
 number from the Vstr string.


<a name="VSTR_TYPE_PARSE_NUM_ERR_ONLY_S"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_NUM_ERR_ONLY_S
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the Vstr string consisted only of spaces.


<a name="VSTR_TYPE_PARSE_NUM_ERR_ONLY_SPM"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_NUM_ERR_ONLY_SPM
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the Vstr string consisted only spaces, and a plus
 or minus sign.


<a name="VSTR_TYPE_PARSE_NUM_ERR_ONLY_SPMX"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_NUM_ERR_ONLY_SPMX
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the Vstr string consisted only spaces, a plus
 or minus sign and a "0x" base 16 prefix.


<a name="VSTR_TYPE_PARSE_NUM_ERR_OOB"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_NUM_ERR_OOB
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the Vstr string had characters in it that where
 out of bounds from the working set.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This out of bounds includes the Vstr string &quot;++&quot; as well as &quot;4A&quot;, when
 parsing in a base less than 11.


<a name="VSTR_TYPE_PARSE_NUM_ERR_OVERFLOW"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_NUM_ERR_OVERFLOW
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the number parsed from the Vstr string would
 overflow the type it is being parsed into, this is only returned when the
 <a href="constants.html#VSTR_FLAG_PARSE_NUM_OVERFLOW">VSTR_FLAG_PARSE_NUM_OVERFLOW</a> flag was passed to the parse function.


<a name="VSTR_TYPE_PARSE_NUM_ERR_NEGATIVE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_NUM_ERR_NEGATIVE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the number parsed from the Vstr string starts
 with a '-' (Hyphen) character when it is supposed to be an unsigned type.


<a name="VSTR_TYPE_PARSE_NUM_ERR_BEG_ZERO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_NUM_ERR_BEG_ZERO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the number parsed from the Vstr string starts
 with a '0' (Digit Zero) character, when the <a href="constants.html#VSTR_FLAG_PARSE_NUM_NO_BEG_ZERO">VSTR_FLAG_PARSE_NUM_NO_BEG_ZERO</a>
 flag was passed to the parse function.


<a name="VSTR_FLAG_PARSE_NUM_DEF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_NUM_DEF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag is 0, and is generally only used as programmer documentation to mean
 no flags are applied to this function.


<a name="VSTR_FLAG_PARSE_NUM_LOCAL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_NUM_LOCAL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag changes the parsing from ASCII numbers into &quot;local&quot; numbers
 (whatever is generated by '0 .. '9' by the host compiler). This can be ignored
 by anyone not using an EBCDIC character set, or something equally weird.


<a name="VSTR_FLAG_PARSE_NUM_SEP"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_NUM_SEP
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the parsing of the '_' (Low Line) separator character
 between the digits of the number, so "1234" and "1_234" would both parse the
 same.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The separator is only allowed within the digits of the number, so &quot; _+_1234&quot;
 would fail as would "_1234".


<a name="VSTR_FLAG_PARSE_NUM_OVERFLOW"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_NUM_OVERFLOW
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag turns on the overflow checking, in other words without it
 <a href="constants.html#VSTR_TYPE_PARSE_NUM_ERR_OVERFLOW">VSTR_TYPE_PARSE_NUM_ERR_OVERFLOW</a> will never be returned as an error code.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The return value with this set is the highest number that can be parsed from
 the beginning of the Vstr string, while the value without this flag would be
 the parsed number modulo the highest number of the type.
</p><p>  For example given a type that had a maximum of 10, then parsing &quot;64&quot; would
 give you 6 with the flag, and 4 without.


<a name="VSTR_FLAG_PARSE_NUM_SPACE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_NUM_SPACE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows one or more ' ' (Space) characters before the number or
 number prefix (Plus Sign, Hyphen).


<a name="VSTR_FLAG_PARSE_NUM_NO_BEG_ZERO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_NUM_NO_BEG_ZERO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag disallows one or more '0' (Digit Zero) characters before the number.


<a name="VSTR_FLAG_PARSE_NUM_NO_BEG_PM"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_NUM_NO_BEG_PM
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag disallows a plus or a minus character before the number.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_parse_ipv4%28%29"><h2>Constants passed to
			 	<a name="vstr_parse_ipv4()"><a href="functions.html#vstr_parse_ipv4()">vstr_parse_ipv4()</a></a>

		      </h2>
</a>
<a name="VSTR_TYPE_PARSE_IPV4_ERR_NONE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV4_ERR_NONE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code has the value 0, and means that no error occurred parsing the
 ipv4 address from the Vstr string.


<a name="VSTR_TYPE_PARSE_IPV4_ERR_IPV4_OOB"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV4_ERR_IPV4_OOB
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the numbers for the ipv4 address in the
 Vstr string where out of bounds.


<a name="VSTR_TYPE_PARSE_IPV4_ERR_IPV4_FULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV4_ERR_IPV4_FULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the ipv4 address wasn't full (Ie. 127/8 is a non
 full ipv4 address with CIDR mask).


<a name="VSTR_TYPE_PARSE_IPV4_ERR_ONLY"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV4_ERR_ONLY
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the ipv4 address, and option mask, wasn't the only
 thing in the Vstr string.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  When this error code is returned, the ip address is still parsed out and as
 usable as if no error had occurred.


<a name="VSTR_TYPE_PARSE_IPV4_ERR_CIDR_OOB"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV4_ERR_CIDR_OOB
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the numbers for the ipv4 CIDR mask in the
 Vstr string where out of bounds.


<a name="VSTR_TYPE_PARSE_IPV4_ERR_CIDR_FULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV4_ERR_CIDR_FULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the ipv4 CIDR mask wasn't full (Ie. 127.0.0.1/ is
 an ipv4 address with a non full ipv4 CIDR mask).


<a name="VSTR_TYPE_PARSE_IPV4_ERR_NETMASK_OOB"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV4_ERR_NETMASK_OOB
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the numbers for the ipv4 netmask in the
 Vstr string where out of bounds.


<a name="VSTR_TYPE_PARSE_IPV4_ERR_NETMASK_FULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV4_ERR_NETMASK_FULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the ipv4 CIDR mask wasn't full (Ie.
 127.0.0.1/255.0 is an ipv4 address with a non full ipv4 netmask).


<a name="VSTR_FLAG_PARSE_IPV4_DEF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV4_DEF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag is 0, and is generally only used as programmer documentation to mean
 no flags are applied to this function.


<a name="VSTR_FLAG_PARSE_IPV4_LOCAL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV4_LOCAL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag changes the parsing from ASCII numbers into &quot;local&quot; numbers
 (whatever is generated by '0 .. '9' by the host compiler). This can be ignored
 by anyone not using an EBCDIC character set, or something equally weird.


<a name="VSTR_FLAG_PARSE_IPV4_ZEROS"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV4_ZEROS
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the use of leading zeros in the ipv4 address and masks.


<a name="VSTR_FLAG_PARSE_IPV4_FULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV4_FULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag changes the parsing so that the function will return an error if a
 non full ipv4 address is given (Ie. 127/8 is a non full ipv4 with a CIDR mask).
 If this flag isn't given the missing numbers are assumed to be zero.


<a name="VSTR_FLAG_PARSE_IPV4_CIDR"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV4_CIDR
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the parsing out of a CIDR mask, if one is present.


<a name="VSTR_FLAG_PARSE_IPV4_CIDR_FULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV4_CIDR_FULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag changes the parsing so that the function will return an error if a
 non full ipv4 CIDR mask is given (Ie. 127.0.0.1/ is an ipv4 with a non full
 ipv4 CIDR mask). If this flag isn't given the missing CIDR mask is assumed to
 be 32.


<a name="VSTR_FLAG_PARSE_IPV4_NETMASK"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV4_NETMASK
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the parsing out of a ipv4 netmask, if one is present.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If both this and the <a href="constants.html#VSTR_FLAG_PARSE_IPV4_CIDR">VSTR_FLAG_PARSE_IPV4_CIDR</a> flag is given, then either
 masking interface will be parsed out as no valid CIDR value is a valid netmask
 prefix.


<a name="VSTR_FLAG_PARSE_IPV4_NETMASK_FULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV4_NETMASK_FULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag changes the parsing so that the function will return an error if a
 non full ipv4 CIDR mask is given (Ie. 127.0.0.1/255.0 is an ipv4 with a non
 full ipv4 netmask). If this flag isn't given the missing numbers are assumed to
 be zero.


<a name="VSTR_FLAG_PARSE_IPV4_ONLY"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV4_ONLY
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag changes the parsing so that the function will return an error if the
 entire string isn't used to contain the ipv4 and option mask.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  When this error code is returned, the ip address is still parsed out and as
 usable as if no error had occurred.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_parse_ipv6%28%29"><h2>Constants passed to
			 	<a name="vstr_parse_ipv6()"><a href="functions.html#vstr_parse_ipv6()">vstr_parse_ipv6()</a></a>

		      </h2>
</a>
<a name="VSTR_TYPE_PARSE_IPV6_ERR_NONE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV6_ERR_NONE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code has the value 0, and means that no error occurred parsing the
 ipv6 address from the Vstr string.


<a name="VSTR_TYPE_PARSE_IPV6_ERR_IPV6_OOB"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV6_ERR_IPV6_OOB
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the numbers for the ipv6 address in the
 Vstr string where out of bounds.


<a name="VSTR_TYPE_PARSE_IPV6_ERR_IPV6_FULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV6_ERR_IPV6_FULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the ipv6 address wasn't full (Ie. FFFF/8 is a non
 full ipv6 address with CIDR mask).


<a name="VSTR_TYPE_PARSE_IPV6_ERR_ONLY"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV6_ERR_ONLY
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the ipv6 address, and option mask, wasn't the only
 thing in the Vstr string.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  When this error code is returned, the ip address is still parsed out and as
 usable as if no error had occurred.


<a name="VSTR_TYPE_PARSE_IPV6_ERR_CIDR_OOB"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV6_ERR_CIDR_OOB
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the numbers for the ipv6 CIDR mask in the
 Vstr string where out of bounds.


<a name="VSTR_TYPE_PARSE_IPV6_ERR_CIDR_FULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV6_ERR_CIDR_FULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the ipv6 CIDR mask wasn't full (Ie. F::1/ is
 an ipv6 address with a non full ipv6 CIDR mask).


<a name="VSTR_TYPE_PARSE_IPV6_ERR_IPV6_NULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_PARSE_IPV6_ERR_IPV6_NULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that there is more than one &quot;NULL&quot; point in the
 ipv6 address, for example "F::E::1" has two NULL points and is impossible
 to parse.


<a name="VSTR_FLAG_PARSE_IPV6_DEF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV6_DEF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag is 0, and is generally only used as programmer documentation to mean
 no flags are applied to this function.


<a name="VSTR_FLAG_PARSE_IPV6_LOCAL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV6_LOCAL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag changes the parsing from ASCII numbers into &quot;local&quot; numbers
 (whatever is generated by '0 .. '9' by the host compiler). This can be ignored
 by anyone not using an EBCDIC character set, or something equally weird.


<a name="VSTR_FLAG_PARSE_IPV6_CIDR"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV6_CIDR
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the parsing out of a CIDR mask, if one is present.


<a name="VSTR_FLAG_PARSE_IPV6_CIDR_FULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV6_CIDR_FULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag changes the parsing so that the function will return an error if a
 non full ipv6 CIDR mask is given (Ie. ::1/ is an ipv6 with a non full
 ipv6 CIDR mask). If this flag isn't given the missing CIDR mask is assumed to
 be 32.


<a name="VSTR_FLAG_PARSE_IPV6_ONLY"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_PARSE_IPV6_ONLY
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag changes the parsing so that the function will return an error if the
 entire string isn't used to contain the ipv6 and option mask.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  When this error code is returned, the ip address is still parsed out and as
 usable as if no error had occurred.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20used%20with%20the%20custom%20output%20formatter%20for%20ipv6%20addresses"><h2>Constants used with the custom output formatter for ipv6 addresses</h2>
</a>
<a name="VSTR_TYPE_SC_FMT_CB_IPV6_ALIGNED"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_FMT_CB_IPV6_ALIGNED
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag outputs the ipv6 address as 8 groups of 4 hexadecimal values.
 For example "FFFF:0EEE:00DD:000C:0000:0000:0001:0002" would be an ipv6 address
 output in aligned mode.


<a name="VSTR_TYPE_SC_FMT_CB_IPV6_COMPACT"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_FMT_CB_IPV6_COMPACT
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag outputs the ipv6 address in as small a representation as possible,
 for example "FFFF:EEE:DD:C::1:2" would be an ipv6 address
 output in compact mode.


<a name="VSTR_TYPE_SC_FMT_CB_IPV6_STD"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_FMT_CB_IPV6_STD
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag outputs the ipv6 address as 8 groups of hexadecimal numbers between
 0 and FFFF, this is the format mostly used in standards. documents,
 for example "FFFF:EEE:DD:C:0:0:1:2" would be an ipv6 address
 output in compact mode.


<a name="VSTR_TYPE_SC_FMT_CB_IPV6_IPV4_ALIGNED"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_FMT_CB_IPV6_IPV4_ALIGNED
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag outputs the ipv6 address in the same way as
 <a href="constants.html#VSTR_TYPE_SC_FMT_CB_IPV6_ALIGNED">VSTR_TYPE_SC_FMT_CB_IPV6_ALIGNED</a>, except that the last 2 groups of hexadecimal
 values (the last 4 octets) are replaced with an ipv4 address.


<a name="VSTR_TYPE_SC_FMT_CB_IPV6_IPV4_COMPACT"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_FMT_CB_IPV6_IPV4_COMPACT
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag outputs the ipv6 address in the same way as
 <a href="constants.html#VSTR_TYPE_SC_FMT_CB_IPV6_COMPACT">VSTR_TYPE_SC_FMT_CB_IPV6_COMPACT</a>, except that the last 2 groups of hexadecimal
 values (the last 4 octets) are replaced with an ipv4 address.


<a name="VSTR_TYPE_SC_FMT_CB_IPV6_IPV4_STD"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_FMT_CB_IPV6_IPV4_STD
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag outputs the ipv6 address in the same way as
 <a href="constants.html#VSTR_TYPE_SC_FMT_CB_IPV6_STD">VSTR_TYPE_SC_FMT_CB_IPV6_STD</a>, except that the last 2 groups of hexadecimal
 values (the last 4 octets) are replaced with an ipv4 address.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_split_buf%28%29%2c%20vstr_split_cstr_buf%28%29%2c%20VSTR_SPLIT_CSTR_BUF%28%29%2c%20vstr_split_chrs%28%29%2c%20vstr_split_cstr_chrs%28%29%20and%20VSTR_SPLIT_CSTR_CHRS%28%29"><h2>Constants passed to
			 	<a name="vstr_split_buf()"><a href="functions.html#vstr_split_buf()">vstr_split_buf()</a></a>

		      ,
			 	<a name="vstr_split_cstr_buf()"><a href="functions.html#vstr_split_cstr_buf()">vstr_split_cstr_buf()</a></a>

		      , <a href="functions.html#VSTR_SPLIT_CSTR_BUF()">VSTR_SPLIT_CSTR_BUF()</a>,
			 	<a name="vstr_split_chrs()"><a href="functions.html#vstr_split_chrs()">vstr_split_chrs()</a></a>

		      ,
			 	<a name="vstr_split_cstr_chrs()"><a href="functions.html#vstr_split_cstr_chrs()">vstr_split_cstr_chrs()</a></a>

		       and <a href="functions.html#VSTR_SPLIT_CSTR_CHRS()">VSTR_SPLIT_CSTR_CHRS()</a></h2>
</a>
<a name="VSTR_FLAG_SPLIT_DEF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SPLIT_DEF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag is 0, and is generally only used as programmer documentation to mean
 no flags are applied to this function.


<a name="VSTR_FLAG_SPLIT_BEG_NULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SPLIT_BEG_NULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the split functions to add sections at the beginning of the
 input that have a null string before the match. For example the input
 "::abcd:..." split on ":" would have 2 sections at positions 1 and 2
 of length 0, without this flag the first section would be at position 3 with
 length 4.


<a name="VSTR_FLAG_SPLIT_MID_NULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SPLIT_MID_NULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the split functions to add sections in the middle of the
 input that have a null string between 2 matches. For example the input
 "a::abcd:..." split on ":" would have the second section at position 3
 of length 0, without this flag the second section would be at position 4 of
 length 4.


<a name="VSTR_FLAG_SPLIT_END_NULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SPLIT_END_NULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the split functions to add sections at the end of the
 input that have a null string after a match. For example the input
 "a::" split on ":" would have the second section at position 3
 of length 0, without this flag there would only be one section added.


<a name="VSTR_FLAG_SPLIT_POST_NULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SPLIT_POST_NULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the split functions to add a final post section of the
 input that ends with a match. For example the input "a:" split on ":" would
 have the second section at position 3 (outside the range of the input)
 of length 0, without this flag there would only be one section added.


<a name="VSTR_FLAG_SPLIT_NO_RET"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SPLIT_NO_RET
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the split functions to return 1, when the Vstr sections
 doesn't have any more room. Without the flag the split functions would
 calculate the number of splits that would have been added if there was room
 in the Vstr sections.


<a name="VSTR_FLAG_SPLIT_REMAIN"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SPLIT_REMAIN
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag changes the split functions, when used with a limit, so that the
 last section added is for the remainder of the input.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_sects_foreach%28%29"><h2>Constants passed to
			 	<a name="vstr_sects_foreach()"><a href="functions.html#vstr_sects_foreach()">vstr_sects_foreach()</a></a>

		      </h2>
</a>
<a name="VSTR_FLAG_SECTS_FOREACH_DEF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SECTS_FOREACH_DEF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag is 0, and is generally only used as programmer documentation to mean
 no flags are applied to this function.


<a name="VSTR_FLAG_SECTS_FOREACH_BACKWARD"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SECTS_FOREACH_BACKWARD
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag changes the foreach function so that it goes through the sections
 backward (from the end to the beginning).


<a name="VSTR_FLAG_SECTS_FOREACH_ALLOW_NULL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_FLAG_SECTS_FOREACH_ALLOW_NULL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag changes the foreach function so that it calls the foreach callback
 on sections of null length (a non zero position with a zero length).


<a name="VSTR_TYPE_SECTS_FOREACH_DEF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SECTS_FOREACH_DEF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This return value is 0, and is generally only used as programmer
 documentation to mean nothing special should happen on return from the
 callback.


<a name="VSTR_TYPE_SECTS_FOREACH_DEL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SECTS_FOREACH_DEL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This return value tells the foreach function to delete the current section
 before the next callback is called.


<a name="VSTR_TYPE_SECTS_FOREACH_RET"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SECTS_FOREACH_RET
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This return value tells the foreach function to return immediately (it does
 the same thing as a break statement in a C for loop.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20used%20with%20the%20callback%20from%20vstr_cache_add_cb%28%29"><h2>Constants used with the callback from <a href="functions.html#vstr_cache_add_cb()">vstr_cache_add_cb()</a></h2>
</a>
<a name="VSTR_TYPE_CACHE_ADD"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_CACHE_ADD
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type means that an add operation has just happened on the Vstr string,
 the position and length arguments are as taken from one of the vstr_add_*
 functions.


<a name="VSTR_TYPE_CACHE_DEL"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_CACHE_DEL
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type means that a delete operation has just happened on the Vstr string,
 the position and length arguments are as taken from the <a href="functions.html#vstr_del()">vstr_del()</a> function.


<a name="VSTR_TYPE_CACHE_SUB"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_CACHE_SUB
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type means that a substitute operation has just happened on the
 Vstr string, the position and length arguments are as taken from one of the
 vstr_sub_* functions.


<a name="VSTR_TYPE_CACHE_FREE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_CACHE_FREE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This type means that the data in the cache needs to be free()'d, the callback
 should always return NULL when this type is passed in.
</p><p>  The position and length arguments are undefined.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_sc_mmap_fd%28%29%20and%20vstr_sc_mmap_file%28%29"><h2>Constants passed to
			 	<a name="vstr_sc_mmap_fd()"><a href="functions.html#vstr_sc_mmap_fd()">vstr_sc_mmap_fd()</a></a>

		       and
			 	<a name="vstr_sc_mmap_file()"><a href="functions.html#vstr_sc_mmap_file()">vstr_sc_mmap_file()</a></a>

		      </h2>
</a>
<a name="VSTR_TYPE_SC_MMAP_FD_ERR_NONE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_MMAP_FD_ERR_NONE
</a><a name="VSTR_TYPE_SC_MMAP_FILE_ERR_NONE"><br><strong>Constant: </strong> VSTR_TYPE_SC_MMAP_FILE_ERR_NONE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code has the value 0, and means that no error occurred adding the
 mapping into the Vstr string.


<a name="VSTR_TYPE_SC_MMAP_FILE_ERR_OPEN_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_MMAP_FILE_ERR_OPEN_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to open() returned -1, errno is set.


<a name="VSTR_TYPE_SC_MMAP_FD_ERR_FSTAT_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_MMAP_FD_ERR_FSTAT_ERRNO
</a><a name="VSTR_TYPE_SC_MMAP_FILE_ERR_FSTAT_ERRNO"><br><strong>Constant: </strong> VSTR_TYPE_SC_MMAP_FILE_ERR_FSTAT_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to fstat() returned -1, errno is set.


<a name="VSTR_TYPE_SC_MMAP_FD_ERR_MMAP_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_MMAP_FD_ERR_MMAP_ERRNO
</a><a name="VSTR_TYPE_SC_MMAP_FILE_ERR_MMAP_ERRNO"><br><strong>Constant: </strong> VSTR_TYPE_SC_MMAP_FILE_ERR_MMAP_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to mmap() returned -1, errno is set.


<a name="VSTR_TYPE_SC_MMAP_FILE_ERR_CLOSE_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_MMAP_FILE_ERR_CLOSE_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to close() returned -1, errno is set.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Even though this is an error, the mapping has already occurred and was
 successful.
</p><p>  If another error occurred (Eg. fstat()/mmap()), then any errors from close()
 will be hidden.


<a name="VSTR_TYPE_SC_MMAP_FD_ERR_MEM"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_MMAP_FD_ERR_MEM
</a><a name="VSTR_TYPE_SC_MMAP_FILE_ERR_MEM"><br><strong>Constant: </strong> VSTR_TYPE_SC_MMAP_FILE_ERR_MEM
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that memory could not be allocated.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  To help the programer unify error paths base-&gt;conf-&gt;malloc_bad is set to
 TRUE, and errno is set to ENOMEM.


<a name="VSTR_TYPE_SC_MMAP_FD_ERR_TOO_LARGE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_MMAP_FD_ERR_TOO_LARGE
</a><a name="VSTR_TYPE_SC_MMAP_FILE_ERR_TOO_LARGE"><br><strong>Constant: </strong> VSTR_TYPE_SC_MMAP_FILE_ERR_TOO_LARGE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the memory mapping was too big to fit in the
 Vstr string (with LFS extensions files are 63 bits, while on a 32 bit
 computer memory space is still only 32 bits so this isn't a corner case).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  To help the programer unify error paths errno is set to EFBIG.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_sc_read_iov_fd%28%29%2c%20vstr_sc_read_len_fd%28%29%2c%20vstr_sc_read_iov_file%28%29%20and%20vstr_sc_read_len_file%28%29"><h2>Constants passed to
			 	<a name="vstr_sc_read_iov_fd()"><a href="functions.html#vstr_sc_read_iov_fd()">vstr_sc_read_iov_fd()</a></a>

		      ,
			 	<a name="vstr_sc_read_len_fd()"><a href="functions.html#vstr_sc_read_len_fd()">vstr_sc_read_len_fd()</a></a>

		      ,
			 	<a name="vstr_sc_read_iov_file()"><a href="functions.html#vstr_sc_read_iov_file()">vstr_sc_read_iov_file()</a></a>

		       and
			 	<a name="vstr_sc_read_len_file()"><a href="functions.html#vstr_sc_read_len_file()">vstr_sc_read_len_file()</a></a>

		      </h2>
</a>
<a name="VSTR_TYPE_SC_READ_FD_ERR_NONE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_READ_FD_ERR_NONE
</a><a name="VSTR_TYPE_SC_READ_FILE_ERR_NONE"><br><strong>Constant: </strong> VSTR_TYPE_SC_READ_FILE_ERR_NONE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code has the value 0, and means that no error occurred adding the
 read() data into the Vstr string.


<a name="VSTR_TYPE_SC_READ_FILE_ERR_OPEN_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_READ_FILE_ERR_OPEN_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to open() returned -1, errno is set.


<a name="VSTR_TYPE_SC_READ_FD_ERR_FSTAT_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_READ_FD_ERR_FSTAT_ERRNO
</a><a name="VSTR_TYPE_SC_READ_FILE_ERR_FSTAT_ERRNO"><br><strong>Constant: </strong> VSTR_TYPE_SC_READ_FILE_ERR_FSTAT_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to fstat() returned -1, errno is set.


<a name="VSTR_TYPE_SC_READ_FILE_ERR_SEEK_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_READ_FILE_ERR_SEEK_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to lseek() returned -1, errno is set.


<a name="VSTR_TYPE_SC_READ_FD_ERR_READ_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_READ_FD_ERR_READ_ERRNO
</a><a name="VSTR_TYPE_SC_READ_FILE_ERR_READ_ERRNO"><br><strong>Constant: </strong> VSTR_TYPE_SC_READ_FILE_ERR_READ_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to readv() returned -1, errno is set.


<a name="VSTR_TYPE_SC_READ_FILE_ERR_CLOSE_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_READ_FILE_ERR_CLOSE_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to close() returned -1, errno is set.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Even though this is an error, the readv() has already occurred and was
 successful.
</p><p>  If another error occurred (Eg. fstat()/readv()), then any errors from close()
 will be hidden.


<a name="VSTR_TYPE_SC_READ_FD_ERR_EOF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_READ_FD_ERR_EOF
</a><a name="VSTR_TYPE_SC_READ_FILE_ERR_EOF"><br><strong>Constant: </strong> VSTR_TYPE_SC_READ_FILE_ERR_EOF
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to readv() returned 0.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  To help the programer unify error paths errno is set to ENOSPC.


<a name="VSTR_TYPE_SC_READ_FD_ERR_MEM"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_READ_FD_ERR_MEM
</a><a name="VSTR_TYPE_SC_READ_FILE_ERR_MEM"><br><strong>Constant: </strong> VSTR_TYPE_SC_READ_FILE_ERR_MEM
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that memory could not be allocated.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  To help the programer unify error paths base-&gt;conf-&gt;malloc_bad is set to
 TRUE, and errno is set to ENOMEM.


<a name="VSTR_TYPE_SC_READ_FD_ERR_TOO_LARGE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_READ_FD_ERR_TOO_LARGE
</a><a name="VSTR_TYPE_SC_READ_FILE_ERR_TOO_LARGE"><br><strong>Constant: </strong> VSTR_TYPE_SC_READ_FILE_ERR_TOO_LARGE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the memory mapping was too big to fit in the
 Vstr string (with LFS extensions files are 63 bits, while on a 32 bit
 computer memory space is still hard limited to 32 bits so this isn't a
 corner case).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  To help the programer unify error paths errno is set to EFBIG.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_sc_write_fd%28%29%20and%20vstr_sc_write_file%28%29"><h2>Constants passed to
			 	<a name="vstr_sc_write_fd()"><a href="functions.html#vstr_sc_write_fd()">vstr_sc_write_fd()</a></a>

		       and
			 	<a name="vstr_sc_write_file()"><a href="functions.html#vstr_sc_write_file()">vstr_sc_write_file()</a></a>

		      </h2>
</a>
<a name="VSTR_TYPE_SC_WRITE_FD_ERR_NONE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_WRITE_FD_ERR_NONE
</a><a name="VSTR_TYPE_SC_WRITE_FILE_ERR_NONE"><br><strong>Constant: </strong> VSTR_TYPE_SC_WRITE_FILE_ERR_NONE
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code has the value 0, and means that no error occurred adding the
 read() data into the Vstr string.


<a name="VSTR_TYPE_SC_WRITE_FILE_ERR_SEEK_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_WRITE_FILE_ERR_SEEK_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to lseek() returned -1, errno is set.


<a name="VSTR_TYPE_SC_WRITE_FILE_ERR_OPEN_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_WRITE_FILE_ERR_OPEN_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to open() returned -1, errno is set.


<a name="VSTR_TYPE_SC_WRITE_FD_ERR_WRITE_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_WRITE_FD_ERR_WRITE_ERRNO
</a><a name="VSTR_TYPE_SC_WRITE_FILE_ERR_WRITE_ERRNO"><br><strong>Constant: </strong> VSTR_TYPE_SC_WRITE_FILE_ERR_WRITE_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to writev() returned -1, errno is set.


<a name="VSTR_TYPE_SC_WRITE_FILE_ERR_CLOSE_ERRNO"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_WRITE_FILE_ERR_CLOSE_ERRNO
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the call to close() returned -1, errno is set.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Even though this is an error, the mapping has already occurred and happened
 successfully.
</p><p>  If another error occurred (Eg. writev()), then any errors from close() will be
 hidden.


<a name="VSTR_TYPE_SC_WRITE_FD_ERR_MEM"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_TYPE_SC_WRITE_FD_ERR_MEM
</a><a name="VSTR_TYPE_SC_WRITE_FILE_ERR_MEM"><br><strong>Constant: </strong> VSTR_TYPE_SC_WRITE_FILE_ERR_MEM
</a>
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that memory could not be allocated.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  To help the programer unify error paths base-&gt;conf-&gt;malloc_bad is set to
 TRUE, and errno is set to ENOMEM.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_cntl_base%28%29"><h2>Constants passed to
			 	<a name="vstr_cntl_base()"><a href="functions.html#vstr_cntl_base()">vstr_cntl_base()</a></a>

		      </h2>
</a>
<a name="VSTR_CNTL_BASE_GET_CONF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_BASE_GET_CONF
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Return Vstr configuration<br>Type<strong>[1]</strong>: struct Vstr_conf **
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the Vstr configuration for the Vstr string


<a name="VSTR_CNTL_BASE_SET_CONF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_BASE_SET_CONF
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Vstr configuration<br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the Vstr configuration for the Vstr string.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This will only return successfully if either the Vstr string is empty, or
 the Vstr configurations have the same value for the NUM_BUF_SZ attribute.
</p><p>  If the Vstr configuration (Parameter[1]) is NULL, then the default
 Vstr configuration will be used.


<a name="VSTR_CNTL_BASE_GET_FLAG_HAVE_CACHE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_BASE_GET_FLAG_HAVE_CACHE
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns value of flag<br>Type<strong>[1]</strong>: int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option lets you know if the Vstr string can cache data, this can only
 be controlled using the <a href="constants.html#VSTR_CNTL_CONF_GET_FLAG_ALLOC_CACHE">VSTR_CNTL_CONF_GET_FLAG_ALLOC_CACHE</a> flag.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_cntl_conf%28%29"><h2>Constants passed to
			 	<a name="vstr_cntl_conf()"><a href="functions.html#vstr_cntl_conf()">vstr_cntl_conf()</a></a>

		      </h2>
</a>
<a name="VSTR_CNTL_CONF_GET_NUM_BUF_SZ"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_NUM_BUF_SZ
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns allocated size of data portion of _BUF nodes<br>Type<strong>[1]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the size of the allocated portion of a _BUF type node.


<a name="VSTR_CNTL_CONF_SET_NUM_BUF_SZ"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_NUM_BUF_SZ
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Allocated size of data portion of _BUF nodes<br>Type<strong>[1]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the size of the allocated portion of a _BUF type node.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This will fail if Vstr strings are using the Vstr configuration.
</p><p>  The value cannot be higher than <a href="constants.html#VSTR_MAX_NODE_BUF">VSTR_MAX_NODE_BUF</a>.


<a name="VSTR_CNTL_CONF_GET_NUM_IOV_MIN_ALLOC"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_NUM_IOV_MIN_ALLOC
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns size of minimum iovec allocation<br>Type<strong>[1]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the size of the minimum allocation to do when expanding
 the iovec cache.


<a name="VSTR_CNTL_CONF_SET_NUM_IOV_MIN_ALLOC"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_NUM_IOV_MIN_ALLOC
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Size of minimum iovec allocation<br>Type<strong>[1]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the size of the minimum allocation to do when expanding
 the iovec cache.


<a name="VSTR_CNTL_CONF_GET_NUM_IOV_MIN_OFFSET"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_NUM_IOV_MIN_OFFSET
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns post allocation offset for iovec cache<br>Type<strong>[1]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the offset on the iovec cache after an iovec allocation.


<a name="VSTR_CNTL_CONF_SET_NUM_IOV_MIN_OFFSET"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_NUM_IOV_MIN_OFFSET
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Post allocation offset for iovec cache<br>Type<strong>[1]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the offset on the iovec cache after an iovec allocation.


<a name="VSTR_CNTL_CONF_GET_NUM_REF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_NUM_REF
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns number of references<br>Type<strong>[1]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the number of references to the Vstr configuration.


<a name="VSTR_CNTL_CONF_SET_LOC_CSTR_AUTO_NAME_NUMERIC"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_LOC_CSTR_AUTO_NAME_NUMERIC
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Name of system LC_NUMERIC locale<br>Type<strong>[1]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the LC_NUMERIC variables in the Vstr configuration to be
 those specified in the system locale (Parameter[1]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Passing NULL as the name will use the current system LC_NUMERIC locale.


<a name="VSTR_CNTL_CONF_GET_LOC_CSTR_NAME_NUMERIC"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_LOC_CSTR_NAME_NUMERIC
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns name of current LC_NUMERIC locale.<br>Type<strong>[1]</strong>: const char **
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the name of the LC_NUMERIC locale.


<a name="VSTR_CNTL_CONF_SET_LOC_CSTR_NAME_NUMERIC"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_LOC_CSTR_NAME_NUMERIC
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Name of LC_NUMERIC locale in Vstr configuration<br>Type<strong>[1]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the name of the LC_NUMERIC locale.


<a name="VSTR_CNTL_CONF_GET_LOC_CSTR_DEC_POINT"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_LOC_CSTR_DEC_POINT
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns decimal point C string<br>Type<strong>[1]</strong>: const char **
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the value of the decimal point LC_NUMERIC locale
 variable.


<a name="VSTR_CNTL_CONF_SET_LOC_CSTR_DEC_POINT"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_LOC_CSTR_DEC_POINT
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Decimal point C string<br>Type<strong>[1]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the value of the decimal point LC_NUMERIC locale
 variable.


<a name="VSTR_CNTL_CONF_GET_LOC_CSTR_THOU_SEP"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_LOC_CSTR_THOU_SEP
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns thousands separator C string<br>Type<strong>[1]</strong>: const char **
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the value of the thousands separator LC_NUMERIC locale
 variable.


<a name="VSTR_CNTL_CONF_SET_LOC_CSTR_THOU_SEP"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_LOC_CSTR_THOU_SEP
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Thousands separator C string<br>Type<strong>[1]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the value of the thousands separator LC_NUMERIC locale
 variable.


<a name="VSTR_CNTL_CONF_GET_LOC_CSTR_THOU_GRP"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_LOC_CSTR_THOU_GRP
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns <br>Type<strong>[1]</strong>: const char **
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the value of the thousands grouping LC_NUMERIC locale
 variable.


<a name="VSTR_CNTL_CONF_SET_LOC_CSTR_THOU_GRP"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_LOC_CSTR_THOU_GRP
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: <br>Type<strong>[1]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the value of the thousands grouping LC_NUMERIC locale
 variable. 


<a name="VSTR_CNTL_CONF_GET_FLAG_IOV_UPDATE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_FLAG_IOV_UPDATE
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns value of flag<br>Type<strong>[1]</strong>: int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will return the status of the flag that allows the vstr functions
 to update the iovec cache when doing add/del operations on Vstr strings.


<a name="VSTR_CNTL_CONF_SET_FLAG_IOV_UPDATE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_FLAG_IOV_UPDATE
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Value of flag<br>Type<strong>[1]</strong>: int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will allow the vstr functions to update the iovec cache when
 doing add/del operations on Vstr strings.


<a name="VSTR_CNTL_CONF_GET_FLAG_DEL_SPLIT"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_FLAG_DEL_SPLIT
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns value of flag<br>Type<strong>[1]</strong>: int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will return the status of the flag that allows the vstr functions
 to split _BUF nodes on del operations to Vstr strings.


<a name="VSTR_CNTL_CONF_SET_FLAG_DEL_SPLIT"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_FLAG_DEL_SPLIT
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Value of flag<br>Type<strong>[1]</strong>: int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will allow the vstr functions to split _BUF nodes on a
 del operations to Vstr strings.


<a name="VSTR_CNTL_CONF_GET_FLAG_ALLOC_CACHE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_FLAG_ALLOC_CACHE
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns value of flag<br>Type<strong>[1]</strong>: int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will return the status of the flag that allows Vstr strings to
 cache data.


<a name="VSTR_CNTL_CONF_SET_FLAG_ALLOC_CACHE"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_FLAG_ALLOC_CACHE
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Value of flag<br>Type<strong>[1]</strong>: int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will allow the Vstr strings made from the Vstr configuration to
 cache data.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If this option is turned off <a href="functions.html#vstr_cache_add_cb()">vstr_cache_add_cb()</a> will not work on Vstr strings
 made from the the Vstr configuration. However each Vstr string will become
 smaller due to the lack of cache.


<a name="VSTR_CNTL_CONF_GET_FMT_CHAR_ESC"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_FMT_CHAR_ESC
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns value of escape character for custom format specifiers<br>Type<strong>[1]</strong>: char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will return the character used for specifying custom format
 specifiers in the <a href="functions.html#vstr_add_vfmt()">vstr_add_vfmt()</a> function.


<a name="VSTR_CNTL_CONF_SET_FMT_CHAR_ESC"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_FMT_CHAR_ESC
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Value of escape character for custom format specifiers<br>Type<strong>[1]</strong>: int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will allow the Vstr strings using the Vstr configuration to
 use custom format specifiers in the <a href="functions.html#vstr_fmt_vfmt()">vstr_fmt_vfmt()</a> function.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If this option is set to 0 ('\0') then <a href="functions.html#vstr_fmt_vfmt()">vstr_fmt_vfmt()</a> acts like
 <a href="functions.html#vstr_fmt_vsysfmt()">vstr_fmt_vsysfmt()</a>.


<a name="VSTR_CNTL_CONF_GET_NUM_SPARE_BUF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_NUM_SPARE_BUF
</a><a name="VSTR_CNTL_CONF_GET_NUM_SPARE_NON"><br><strong>Constant: </strong> VSTR_CNTL_CONF_GET_NUM_SPARE_NON
</a><a name="VSTR_CNTL_CONF_GET_NUM_SPARE_PTR"><br><strong>Constant: </strong> VSTR_CNTL_CONF_GET_NUM_SPARE_PTR
</a><a name="VSTR_CNTL_CONF_GET_NUM_SPARE_REF"><br><strong>Constant: </strong> VSTR_CNTL_CONF_GET_NUM_SPARE_REF
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns number of spare nodes to have for the specified type<br>Type<strong>[1]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option gets the current number of spare nodes of the specified type.


<a name="VSTR_CNTL_CONF_SET_NUM_SPARE_BUF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_NUM_SPARE_BUF
</a><a name="VSTR_CNTL_CONF_SET_NUM_SPARE_NON"><br><strong>Constant: </strong> VSTR_CNTL_CONF_SET_NUM_SPARE_NON
</a><a name="VSTR_CNTL_CONF_SET_NUM_SPARE_PTR"><br><strong>Constant: </strong> VSTR_CNTL_CONF_SET_NUM_SPARE_PTR
</a><a name="VSTR_CNTL_CONF_SET_NUM_SPARE_REF"><br><strong>Constant: </strong> VSTR_CNTL_CONF_SET_NUM_SPARE_REF
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Number of spare nodes to have for the specified type<br>Type<strong>[1]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option is will set the number of spare nodes of the specified type,
 by calling either <a href="functions.html#vstr_make_spare_nodes()">vstr_make_spare_nodes()</a> or <a href="functions.html#vstr_free_spare_nodes()">vstr_free_spare_nodes()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  When the value specified is higher and it calls <a href="functions.html#vstr_make_spare_nodes()">vstr_make_spare_nodes()</a> then
 a return value of FALSE means that there was a malloc error, just as if you
 called vstr_make_nodes directly.


<a name="VSTR_CNTL_CONF_GET_FLAG_ATOMIC_OPS"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_GET_FLAG_ATOMIC_OPS
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns value of flag<br>Type<strong>[1]</strong>: int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will return the status of the flag that makes the vstr functions
 do atomic alterations to the string data. If the flag is set then all functions
 will either return successfully, or not alter the data of the vstr from the
 point of view of <a href="functions.html#vstr_cmp()">vstr_cmp()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This is mainly a speedup to the vstr_sub_*() functions and the functions that
 use them, like vstr_conv_*(). It is true by default, so all function
 operations are atomic.


<a name="VSTR_CNTL_CONF_SET_FLAG_ATOMIC_OPS"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_FLAG_ATOMIC_OPS
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Value of flag<br>Type<strong>[1]</strong>: int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the status of the flag that makes the vstr functions
 do atomic alterations to the string data. If the flag is set then all functions
 will either return successfully, or not alter the data of the vstr from the
 point of view of <a href="functions.html#vstr_cmp()">vstr_cmp()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This is mainly a speedup to the vstr_sub_*() functions and the functions that
 use them, like vstr_conv_*(). It is true by default, so all function
 operations are atomic.


<a name="VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_BUF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_BUF
</a><a name="VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_NON"><br><strong>Constant: </strong> VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_NON
</a><a name="VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_PTR"><br><strong>Constant: </strong> VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_PTR
</a><a name="VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_REF"><br><strong>Constant: </strong> VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_REF
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Minimum number of spare nodes to have for the specified type<br>Type<strong>[1]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[2]</strong>: Maximum number of spare nodes to have for the specified type<br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will make the number of spare nodes of the specified type fit
 into the range given, by calling either <a href="functions.html#vstr_make_spare_nodes()">vstr_make_spare_nodes()</a> or 
 <a href="functions.html#vstr_free_spare_nodes()">vstr_free_spare_nodes()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  When the value specified is higher and it calls <a href="functions.html#vstr_make_spare_nodes()">vstr_make_spare_nodes()</a> then
 a return value of FALSE means that there was a malloc error, just as if you
 called vstr_make_nodes directly.


</td></tr></table><table width="90%"><tr><td bgcolor="#DDDDFF"><a name="Constants%20passed%20to%20vstr_cntl_opt%28%29"><h2>Constants passed to
			 	<a name="vstr_cntl_opt()"><a href="functions.html#vstr_cntl_opt()">vstr_cntl_opt()</a></a>

		      </h2>
</a>
<a name="VSTR_CNTL_OPT_GET_CONF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_OPT_GET_CONF
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Returns Vstr configuration<br>Type<strong>[1]</strong>: struct Vstr_conf **
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the default Vstr configuration.


<a name="VSTR_CNTL_OPT_SET_CONF"></td></tr></table><table width="80%"><tr><td bgcolor="#DDDDDD">
<strong>Constant: </strong> VSTR_CNTL_OPT_SET_CONF
</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Vstr configuration<br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the default Vstr configuration.


</td></tr></table>
</body></html>