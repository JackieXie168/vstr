<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>c2html for: ex_zcat.c</title>
    <link rel="stylesheet" type="text/css" href="f_c.css">
  </head>
  <body>
     <h1>ex_zcat.c</h1>
<pre class="c2html">
<span class="comment">/* automatically decompresses data from either gzip of bzip2 formats
 * very usefull so you can do tar -xzvf &lt;foo&gt; and it just works */</span>

#<span class="cppinclude">include</span> <span class="str">"ex_utils.h"</span>


<span class="comment">/* compression libraries */</span>

#<span class="cppinclude">include</span> &lt;zlib.h&gt;
#<span class="cppdefine">define</span> BZ_NO_STDIO 1
#<span class="cppinclude">include</span> &lt;bzlib.h&gt;


#<span class="cppdefine">define</span> EX_ZCAT_USE_MMAP 1

#<span class="cppdefine">define</span> EX_ZCAT_USAGE_ENCOMPRESS 1
#<span class="cppdefine">define</span> EX_ZCAT_USAGE_DECOMPRESS 2

#<span class="cppdefine">define</span> EX_ZCAT_TYPE_ERROR    <span class="num0">0</span>
#<span class="cppdefine">define</span> EX_ZCAT_TYPE_NONE     1
#<span class="cppdefine">define</span> EX_ZCAT_TYPE_BZIP2    2
#<span class="cppdefine">define</span> EX_ZCAT_TYPE_GZIP     3
#<span class="cppdefine">define</span> EX_ZCAT_TYPE_COMPRESS 4


<span class="static">static</span> <span class="int">int</span> ex_zcat_f_type = EX_ZCAT_TYPE_ERROR;

union ex_zcat_lib_decomp_u
{
 z_stream gzip;
 bz_stream bzip2;
} ex_zcat_lib_decomp_data;

<span class="static">static</span> <span class="int">int</span> ex_zcat_data_open = <span class="false">FALSE</span>;

<span class="static">static</span> <span class="int">int</span> ex_zcat_open(<span class="vstrbase">Vstr_base</span> *s2)
{
  <span class="int">int</span> not_enough = <span class="false">FALSE</span>;
  <span class="int">int</span> f_type = EX_ZCAT_TYPE_NONE;

  <span class="if">if</span> (ex_zcat_data_open) <span class="comment">/* allow open to be called many times */</span>
    <span class="return">return</span> (<span class="true">TRUE</span>);
  
  <span class="if">if</span> (s2-&gt;len &lt; 3) not_enough = <span class="true">TRUE</span>; <span class="else">else</span>
  {
    <span class="unsigned">unsigned</span> <span class="char">char</span> buf[3] = {0x1F, 0x8B, 0x08};
    <span class="if">if</span> (vstr_cmp_buf_eq(s2, 1, sizeof(buf), buf, sizeof(buf)))
      f_type = EX_ZCAT_TYPE_GZIP;
  }

  <span class="if">if</span> (s2-&gt;len &lt; 4) not_enough = <span class="true">TRUE</span>; <span class="else">else</span>
  {
    <span class="unsigned">unsigned</span> <span class="char">char</span> buf[3] = {0x42, 0x5A, 0x68};

    <span class="if">if</span> (vstr_cmp_buf_eq(s2, 1, sizeof(buf), buf, sizeof(buf)) &amp;&amp;
        <span class="comment">/* byte four is the level -1 .. -9 */</span>
        (vstr_export_chr(s2, 4) &gt;= 0x31) &amp;&amp; (vstr_export_chr(s2, 4) &lt;= 0x39))
      f_type = EX_ZCAT_TYPE_BZIP2;

  }

  memset(&amp;ex_zcat_lib_decomp_data, <span class="num0">0</span>, sizeof(ex_zcat_lib_decomp_data));

  <span class="switch">switch</span> (f_type)
  {
    <span class="case">case</span> EX_ZCAT_TYPE_NONE:
      <span class="if">if</span> (not_enough)
        <span class="return">return</span> (<span class="false">FALSE</span>);
      f_type = EX_ZCAT_TYPE_NONE;
      <span class="break">break</span>;

    <span class="case">case</span> EX_ZCAT_TYPE_GZIP:
    {
      union ex_zcat_lib_decomp_u *u = &amp;ex_zcat_lib_decomp_data;
      <span class="unsigned">unsigned</span> <span class="int">int</span> method = vstr_export_chr(s2, 3);
      <span class="unsigned">unsigned</span> <span class="int">int</span> flags  = vstr_export_chr(s2, 4);
      <span class="sizet">size_t</span> pos = 1;

      <span class="comment">/* magic  | magic | method | flags |
         stamp  | stamp | stamp  | stamp |
         Xflags | OS    | */</span>
      pos += 10;

      <span class="assert">ASSERT</span>(method == 0x08);

      <span class="if">if</span> (flags &amp; 0x04)
      { <span class="comment">/* extra field */</span>
        <span class="char">char</span> buf[2];
        <span class="unsigned">unsigned</span> <span class="int">int</span> xfield_len = <span class="num0">0</span>;

        <span class="if">if</span> ((pos &lt;= s2-&gt;len) &amp;&amp; (vstr_sc_posdiff(pos, s2-&gt;len) &lt; 2))
          <span class="return">return</span> (<span class="false">FALSE</span>); <span class="comment">/* not all of gzip header */</span>

        vstr_export_buf(s2, pos, 2, buf, sizeof(buf));
        xfield_len |= buf[1]; xfield_len &lt;&lt;= 8;
        xfield_len |= buf[0];

        xfield_len += 2;
        <span class="if">if</span> ((pos &lt;= s2-&gt;len) &amp;&amp; (vstr_sc_posdiff(pos, s2-&gt;len) &lt; xfield_len))
          <span class="return">return</span> (<span class="false">FALSE</span>); <span class="comment">/* not all of gzip header */</span>
        pos += xfield_len;
      }
      <span class="if">if</span> (flags &amp; 0x08)
      { <span class="comment">/* name is present */</span>
        <span class="sizet">size_t</span> len = vstr_sc_posdiff(pos, s2-&gt;len);
        <span class="sizet">size_t</span> end_name = vstr_srch_chr_fwd(s2, pos, len, <span class="num0">0</span>);
        <span class="if">if</span> (!end_name)
          <span class="return">return</span> (<span class="false">FALSE</span>);
        pos += vstr_sc_posdiff(pos, end_name);
      }
      <span class="if">if</span> (flags &amp; 0x10)
      { <span class="comment">/* comment is present */</span>
        <span class="sizet">size_t</span> len = vstr_sc_posdiff(pos, s2-&gt;len);
        <span class="sizet">size_t</span> end_name = vstr_srch_chr_fwd(s2, pos, len, <span class="num0">0</span>);
        <span class="if">if</span> (!end_name)
          <span class="return">return</span> (<span class="false">FALSE</span>);
        pos += vstr_sc_posdiff(pos, end_name);
      }
      <span class="if">if</span> (flags &amp; 0x02) <span class="comment">/* continuation/header CRC --
                         * gzip and zlib do it differently */</span>
        pos += 2;
      vstr_del(s2, 1, pos - 1);

      <span class="if">if</span> (inflateInit2(&amp;u-&gt;gzip, -MAX_WBITS) != Z_OK)
        <span class="err">errx</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"gzip init: failed"</span>);
    }
    <span class="break">break</span>;

    <span class="case">case</span> EX_ZCAT_TYPE_BZIP2:
    {
      union ex_zcat_lib_decomp_u *u = &amp;ex_zcat_lib_decomp_data;

      <span class="if">if</span> (BZ2_bzDecompressInit(&amp;u-&gt;bzip2, <span class="false">FALSE</span>, <span class="false">FALSE</span>) != BZ_OK)
        <span class="err">errx</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"bzip2 beg: failed"</span>);
    }
    <span class="break">break</span>;

    <span class="case">case</span> EX_ZCAT_TYPE_COMPRESS:

    <span class="default">default</span>:
      <span class="assert">assert</span>(<span class="false">FALSE</span>);
  }

  ex_zcat_f_type    = f_type;
  ex_zcat_data_open = <span class="true">TRUE</span>;

  <span class="return">return</span> (<span class="true">TRUE</span>);
}

<span class="static">static</span> <span class="void">void</span> ex_zcat_close(<span class="void">void</span>)
{
  union ex_zcat_lib_decomp_u *u = &amp;ex_zcat_lib_decomp_data;

  <span class="if">if</span> (!ex_zcat_data_open)
    <span class="return">return</span>;

  <span class="switch">switch</span> (ex_zcat_f_type)
  {
    <span class="case">case</span> EX_ZCAT_TYPE_NONE:
      <span class="break">break</span>;

    <span class="case">case</span> EX_ZCAT_TYPE_GZIP:
      <span class="if">if</span> (inflateEnd(&amp;u-&gt;gzip) != Z_OK)
        <span class="err">errx</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"gzip end: failed"</span>);
      <span class="break">break</span>;

    <span class="case">case</span> EX_ZCAT_TYPE_BZIP2:
      <span class="if">if</span> (BZ2_bzDecompressEnd(&amp;u-&gt;bzip2) != BZ_OK)
        <span class="err">errx</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"bzip2 end: failed"</span>);
      <span class="break">break</span>;

    <span class="case">case</span> EX_ZCAT_TYPE_COMPRESS:

    <span class="default">default</span>:
      <span class="assert">assert</span>(<span class="false">FALSE</span>);
  }

  ex_zcat_data_open = <span class="false">FALSE</span>;
}

<span class="static">static</span> <span class="int">int</span> ex_zcat_process(<span class="vstrbase">Vstr_base</span> *s1, <span class="vstrbase">Vstr_base</span> *s2, <span class="int">int</span> last)
{
  union ex_zcat_lib_decomp_u *u = &amp;ex_zcat_lib_decomp_data;
  struct iovec *io_s2 = <span class="null">NULL</span>;
  struct iovec *io_s1 = <span class="null">NULL</span>;
  <span class="char">char</span>  *io_r_ptr = <span class="null">NULL</span>;
  <span class="sizet">size_t</span> io_r_len = <span class="num0">0</span>;
  <span class="char">char</span>  *io_w_ptr = <span class="null">NULL</span>;
  <span class="sizet">size_t</span> io_w_len = <span class="num0">0</span>;
  <span class="sizet">size_t</span> bytes_io_r = <span class="num0">0</span>;
  <span class="sizet">size_t</span> bytes_io_w = <span class="num0">0</span>;
  <span class="int">int</span> at_end = <span class="false">FALSE</span>;

  <span class="if">if</span> (!ex_zcat_open(s2))
    <span class="return">return</span> (<span class="false">FALSE</span>);

  <span class="if">if</span> (ex_zcat_f_type == EX_ZCAT_TYPE_NONE)
  { <span class="comment">/* special quick case ... */</span>
    <span class="if">if</span> (!s2-&gt;len)
      <span class="return">return</span> (<span class="false">FALSE</span>);

    vstr_mov(s1, s1-&gt;len, s2, 1, s2-&gt;len);
    <span class="return">return</span> (<span class="true">TRUE</span>);
  }

  <span class="if">if</span> (ex_zcat_f_type == EX_ZCAT_TYPE_GZIP)
  { <span class="comment">/* gzip needs a bunch of data at a time... */</span>
    <span class="if">if</span> (!last &amp;&amp; (s2-&gt;len &lt; (4 * 1024)))
      <span class="return">return</span> (<span class="true">TRUE</span>);
  }

  <span class="comment">/* setup decompressor input... */</span>
  <span class="if">if</span> (vstr_export_iovec_ptr_all(s2, &amp;io_s2, <span class="null">NULL</span>))
  {
    io_r_ptr = io_s2[0].iov_base;
    io_r_len = io_s2[0].iov_len;
  }
  <span class="else">else</span> <span class="if">if</span> (s2-&gt;len)
    <span class="errno">errno</span> = ENOMEM, <span class="err">err</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"decompress"</span>);

  <span class="comment">/* setup decompressor output... */</span>
  {
    <span class="unsigned">unsigned</span> <span class="int">int</span> dummy_num;

    <span class="if">if</span> (!vstr_add_iovec_buf_beg(s1, s1-&gt;len, 1, 2, &amp;io_s1, &amp;dummy_num))
      <span class="errno">errno</span> = ENOMEM, <span class="err">err</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"decompress"</span>);

    io_w_ptr = io_s1[0].iov_base;
    io_w_len = io_s1[0].iov_len;
  }

  <span class="switch">switch</span> (ex_zcat_f_type)
  {
    <span class="case">case</span> EX_ZCAT_TYPE_GZIP:
    {
      <span class="int">int</span> ret = Z_STREAM_ERROR;

      <span class="if">if</span> (!io_r_len)
      {
        ex_zcat_close();
        <span class="break">break</span>;
      }

      u-&gt;gzip.next_in   = io_r_ptr;
      u-&gt;gzip.avail_in  = io_r_len;
      u-&gt;gzip.next_out  = io_w_ptr;
      u-&gt;gzip.avail_out = io_w_len;
      ret = inflate(&amp;u-&gt;gzip, last ? Z_SYNC_FLUSH : Z_NO_FLUSH);
      bytes_io_r = io_r_len - u-&gt;gzip.avail_in;
      bytes_io_w = io_w_len - u-&gt;gzip.avail_out;
      <span class="if">if</span> (ret == Z_STREAM_END)
      {
        bytes_io_r += 8; <span class="comment">/* remove crap from end of gzip files */</span>
        at_end = <span class="true">TRUE</span>;
        ex_zcat_close();
      }
      <span class="else">else</span> <span class="if">if</span> (ret != Z_OK)
        <span class="err">errx</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"failed %d = %s"</span>, (<span class="int">int</span>)ret, u-&gt;gzip.msg);
    }
    <span class="break">break</span>;

    <span class="case">case</span> EX_ZCAT_TYPE_BZIP2:
    {
      <span class="int">int</span> ret = BZ_SEQUENCE_ERROR;

      u-&gt;bzip2.next_in   = io_r_ptr;
      u-&gt;bzip2.avail_in  = io_r_len;
      u-&gt;bzip2.next_out  = io_w_ptr;
      u-&gt;bzip2.avail_out = io_w_len;
      ret = BZ2_bzDecompress(&amp;u-&gt;bzip2);
      bytes_io_r = io_r_len - u-&gt;bzip2.avail_in;
      bytes_io_w = io_w_len - u-&gt;bzip2.avail_out;

      <span class="if">if</span> (ret == BZ_STREAM_END)
      {
        at_end = <span class="true">TRUE</span>;
        ex_zcat_close();
      }
      <span class="else">else</span> <span class="if">if</span> (ret != BZ_OK)
        <span class="err">errx</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"failed %d"</span>, (<span class="int">int</span>)ret);
    }
    <span class="break">break</span>;

    <span class="case">case</span> EX_ZCAT_TYPE_NONE:
      <span class="assert">assert</span>(<span class="false">FALSE</span>); <span class="comment">/* dealt with above ... as we don't do anything */</span>

    <span class="case">case</span> EX_ZCAT_TYPE_COMPRESS:

    <span class="default">default</span>:
      <span class="assert">assert</span>(<span class="false">FALSE</span>);
      <span class="return">return</span> (<span class="false">FALSE</span>);
  }

  vstr_add_iovec_buf_end(s1, s1-&gt;len, bytes_io_w);
  vstr_del(s2, 1, bytes_io_r);

  <span class="return">return</span> (!at_end);
}

<span class="static">static</span> <span class="void">void</span> ex_zcat_process_limit(<span class="vstrbase">Vstr_base</span> *s1, <span class="vstrbase">Vstr_base</span> *s2,
                                  <span class="unsigned">unsigned</span> <span class="int">int</span> lim)
{
  <span class="while">while</span> (s2-&gt;len &gt; lim)
  {
    <span class="int">int</span> proc_data = ex_zcat_process(s1, s2, !lim);
    
    <span class="if">if</span> (!proc_data &amp;&amp; (io_put(s1, <span class="stdout">STDOUT_FILENO</span>) == IO_BLOCK))
      io_block(<span class="numm1">-1</span>, <span class="stdout">STDOUT_FILENO</span>);
  }
}

<span class="static">static</span> <span class="void">void</span> ex_zcat_read_fd_write_stdout(<span class="vstrbase">Vstr_base</span> *s1, <span class="vstrbase">Vstr_base</span> *s2, <span class="int">int</span> fd)
{
  <span class="while">while</span> (<span class="true">TRUE</span>)
  {
    <span class="int">int</span> io_w_state = IO_OK;
    <span class="int">int</span> io_r_state = io_get(s2, fd);

    <span class="if">if</span> (io_r_state == IO_EOF)
      <span class="break">break</span>;

    ex_zcat_process(s1, s2, <span class="false">FALSE</span>);

    io_w_state = io_put(s1, 1);

    io_limit(io_r_state, fd, io_w_state, 1, s1);
  }

  ex_zcat_process_limit(s1, s2, <span class="num0">0</span>);
}

<span class="int">int</span> main(<span class="int">int</span> argc, <span class="char">char</span> *argv[])
{
  <span class="vstrbase">Vstr_base</span> *s2 = <span class="null">NULL</span>;
  <span class="vstrbase">Vstr_base</span> *s1 = <span class="null">NULL</span>;
  <span class="int">int</span> count = 1; <span class="comment">/* skip the program name */</span>
  <span class="int">int</span> ex_zcat_direction = EX_ZCAT_USAGE_ENCOMPRESS;

  <span class="if">if</span> (argc == 1)
    ex_zcat_direction = EX_ZCAT_USAGE_ENCOMPRESS;
  <span class="else">else</span> <span class="if">if</span> ((argc &gt;= 2) &amp;&amp; !strcmp(argv[1], <span class="str">"-d"</span>))
  {
    ++argv;
    --argc;
    ex_zcat_direction = EX_ZCAT_USAGE_DECOMPRESS;
  }

  <span class="if">if</span> (ex_zcat_direction == EX_ZCAT_USAGE_ENCOMPRESS)
  {
    execvp(<span class="str">"gzip"</span>, argv);
    <span class="exit">exit</span> (<span class="exitfail">EXIT_FAILURE</span>);
  }

  <span class="comment">/* init library etc. */</span>
  s1 = ex_init(&amp;s2);
  
  <span class="if">if</span> (count &gt;= argc)
  {
    io_fd_set_o_nonblock(<span class="stdin">STDIN_FILENO</span>);
    ex_zcat_read_fd_write_stdout(s1, s2, <span class="stdin">STDIN_FILENO</span>);

    ex_zcat_process_limit(s1, s2, <span class="num0">0</span>);
  }

  <span class="comment">/* loop through all arguments, open the file specified
   * and do the read/write loop */</span>
  <span class="while">while</span> (count &lt; argc)
  {
    <span class="unsigned">unsigned</span> <span class="int">int</span> ern = <span class="num0">0</span>;

    <span class="comment">/* try to mmap the file, as that is faster ... */</span>
    <span class="if">if</span> (EX_ZCAT_USE_MMAP &amp;&amp; (s2-&gt;len &lt; EX_MAX_R_DATA_INCORE))
      vstr_sc_mmap_file(s2, s2-&gt;len, argv[count], <span class="num0">0</span>, <span class="num0">0</span>, &amp;ern);

    <span class="if">if</span> ((ern == VSTR_TYPE_SC_MMAP_FILE_ERR_FSTAT_ERRNO) ||
        (ern == VSTR_TYPE_SC_MMAP_FILE_ERR_MMAP_ERRNO) ||
        (ern == VSTR_TYPE_SC_MMAP_FILE_ERR_TOO_LARGE))
    {
      <span class="int">int</span> fd = io_open(argv[count]);

      ex_zcat_read_fd_write_stdout(s1, s2, fd);

      <span class="if">if</span> (close(fd) == <span class="numm1">-1</span>)
        <span class="warn">warn</span>(<span class="str">"close(%s)"</span>, argv[count]);
    }
    <span class="else">else</span> <span class="if">if</span> (ern &amp;&amp; (ern != VSTR_TYPE_SC_MMAP_FILE_ERR_CLOSE_ERRNO))
      <span class="err">err</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"add"</span>);
    <span class="else">else</span>
      ex_zcat_process_limit(s1, s2, <span class="num0">0</span>);
    
    ++count;
  }

  ex_zcat_process_limit(s1, s2, <span class="num0">0</span>);
  io_put_all(s1, <span class="stdout">STDOUT_FILENO</span>);
  
  <span class="exit">exit</span> (ex_exit(s1, s2));
}
</pre>
<!-- C to html convertion of ex_zcat.c -->
<!--   done on Thu May 13 03:35:35 2004 -->
<!--   done by ex_highlight -->

  </body>
</html>
