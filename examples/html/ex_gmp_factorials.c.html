<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>c2html for: ex_gmp_factorials.c</title>
    <link rel="stylesheet" type="text/css" href="f_c.css">
  </head>
  <body>
     <h1>ex_gmp_factorials.c</h1>
<pre class="c2html">
<span class="comment">/* Simple libgmp command, see...

http://www.gnu.org/manual/gmp/html_node/Converting-Integers.html
http://www.gnu.org/manual/gmp/html_node/Integer-Comparisons.html
http://www.gnu.org/manual/gmp/html_node/Miscellaneous-Integer-Functions.html
http://www.gnu.org/manual/gmp/html_node/Integer-Arithmetic.html

http://www.gnu.org/manual/gmp/html_node/Formatted-Output-Strings.html


...it prints the factorial of the first argument, you can check the output
against...

http://www.newdream.net/~sage/old/numbers/fact.htm

...or a POSIX "bc" via. ...

  define f (x) {
    if (x &lt;= 1) return (1);
    return (f(x-1) * x);
  }

*/</span>

<span class="comment">/* we only need output here, so turn off other IO functions */</span>
#<span class="cppdefine">define</span> EX_UTILS_NO_USE_INPUT 1
#<span class="cppdefine">define</span> EX_UTILS_NO_USE_OPEN 1
#<span class="cppinclude">include</span> <span class="str">"ex_utils.h"</span> <span class="comment">/* helper functions */</span>

#<span class="cppinclude">include</span> &lt;limits.h&gt;
#<span class="cppinclude">include</span> &lt;gmp.h&gt;
#<span class="cppinclude">include</span> &lt;locale.h&gt;

<span class="comment">/* if this is enabled we go through the factorials twice, which means we do
 * almost twice as much work ... the output is more readable for small values
 * though */</span>
#<span class="cppdefine">define</span> EX_GMP_FACT_USE_FIELDWIDTH 1

<span class="comment">/* if this is enabled we add the malloc()d string as a reference,
 * which saves doing an extra copy. */</span>
#<span class="cppdefine">define</span> EX_GMP_FACT_USE_REFS 1

<span class="comment">/* This is the custom formatter.
 * Note that this deals with grouping unlike the gmp_*printf() calls */</span>
<span class="static">static</span> <span class="int">int</span> ex__usr_mpz_cb(<span class="vstrbase">Vstr_base</span> *base, <span class="sizet">size_t</span> pos, <span class="vstrfmt">Vstr_fmt_spec</span> *spec,
                          <span class="comment">/* gmp args, need to be in paramter list */</span>
                          <span class="const">const</span> <span class="mpzt">mpz_t</span> val)
{
  <span class="int">int</span> flags = VSTR_FLAG_SC_FMT_CB_BEG_OBJ_NUM; <span class="comment">/* it's a number */</span>
  <span class="sizet">size_t</span> len = <span class="num0">0</span>;
  <span class="int">int</span> ret = <span class="false">FALSE</span>;
  <span class="char">char</span> ui_buf[sizeof(<span class="unsigned">unsigned</span> <span class="long">long</span>) * CHAR_BIT];
  <span class="char">char</span> *buf = <span class="null">NULL</span>;
  <span class="char">char</span> *out_buf = ui_buf;

  <span class="if">if</span> (mpz_sgn(val) == <span class="numm1">-1</span>) <span class="comment">/* it's a negative number */</span>
    flags |= VSTR_FLAG_SC_FMT_CB_BEG_OBJ_NEG;
  
  <span class="if">if</span> (mpz_fits_ulong_p(val)) <span class="comment">/* it's a simple number */</span>
    len = vstr_sc_conv_num10_ulong(ui_buf, sizeof(ui_buf), mpz_get_ui(val));
  <span class="else">else</span> <span class="comment">/* bignum, so get libgmp to export it as a string */</span>
  {
    len = mpz_sizeinbase(val, 10); <span class="comment">/* doesn't include minus sign */</span>
    out_buf = buf = mpz_get_str(<span class="null">NULL</span>, 10, val); <span class="comment">/* dies on malloc error */</span>

    <span class="if">if</span> (mpz_sgn(val) == <span class="numm1">-1</span>) ++out_buf; <span class="comment">/* skip the minus sign */</span>
    <span class="if">if</span> (!out_buf[len - 1])  --len; <span class="comment">/* see documentation for mpz_sizeinbase() */</span>
  }

  <span class="assert">ASSERT</span>(strlen(out_buf) == len);
  
  <span class="comment">/* this deals with things like having the the zero flag (Ie. %0d), or the
   * plus flag (Ie. %+d) or right shifted field widths */</span>
  <span class="if">if</span> (!vstr_sc_fmt_cb_beg(base, &amp;pos, spec, &amp;len, flags))
    <span class="goto">goto</span> mem_fail;
 
  <span class="if">if</span> (spec-&gt;fmt_quote) <span class="comment">/* add number including grouping */</span>
    ret = vstr_sc_add_grpnum_buf(base, pos, out_buf, len);
  <span class="else">else</span> <span class="if">if</span> (!EX_GMP_FACT_USE_REFS || !buf) <span class="comment">/* just add the number */</span>
    ret = vstr_add_buf(base, pos, out_buf, len);
  <span class="else">else</span>
  { <span class="comment">/* create a reference to avoid copying data,
     * assumes mp_set_memory_functions() hasn't been called */</span>
    Vstr_ref *ref = vstr_ref_make_ptr(buf, vstr_ref_cb_free_ptr_ref);

    <span class="if">if</span> (!ref)
      <span class="goto">goto</span> mem_fail;

    ret = vstr_add_ref(base, pos, ref, out_buf - buf, len);
    
    buf = <span class="null">NULL</span>; <span class="comment">/* memory is free'd when the reference is used up */</span>

    <span class="comment">/* remove our reference, if !ret then this will free buf */</span>
    vstr_ref_del(ref);
  }
  
  <span class="comment">/* this deals with left shifted field widths */</span>
  <span class="if">if</span> (!ret || !vstr_sc_fmt_cb_end(base, pos, spec, len))
    <span class="goto">goto</span> mem_fail;

  free(buf);
  
  <span class="return">return</span> (<span class="true">TRUE</span>);

 mem_fail:
  free(buf);
  <span class="return">return</span> (<span class="false">FALSE</span>);
}

<span class="comment">/* we need to jump though an extra function due to the way GMP defines the
 * mpz_t type */</span>
<span class="static">static</span> <span class="int">int</span> ex_usr_mpz_cb(<span class="vstrbase">Vstr_base</span> *base, <span class="sizet">size_t</span> pos, <span class="vstrfmt">Vstr_fmt_spec</span> *spec)
{
  <span class="void">void</span> *mpz = VSTR_FMT_CB_ARG_PTR(spec, <span class="num0">0</span>);

  <span class="return">return</span> (ex__usr_mpz_cb(base, pos, spec, mpz));
}

<span class="comment">/* The code to calculate the factorial... */</span>
<span class="static">static</span> <span class="void">void</span> ex_gmp_fact(<span class="mpzt">mpz_t</span> bignum_ret, <span class="mpzt">mpz_t</span> bignum_cnt, <span class="mpzt">mpz_t</span> bignum_for,
                        <span class="int">int</span> out, <span class="vstrbase">Vstr_base</span> *s1, <span class="int">int</span> ret_max_sz, <span class="int">int</span> cnt_max_sz)
{
  <span class="while">while</span> (mpz_cmp(bignum_cnt, bignum_for) &lt;= <span class="num0">0</span>)
  {
    <span class="int">int</span> w_state = IO_OK;
    
    mpz_mul(bignum_ret, bignum_ret, bignum_cnt);

    <span class="if">if</span> (out)
    { <span class="comment">/* output the current values */</span>
      vstr_add_fmt(s1, s1-&gt;len, <span class="str">"$'*&lt;MPZ:%*p&gt;%s %c $'*&lt;MPZ:%*p&gt;\n"</span>,
                   cnt_max_sz, (<span class="void">void</span> *)bignum_cnt, <span class="str">"!"</span>, <span class="chr">'='</span>,
                   ret_max_sz, (<span class="void">void</span> *)bignum_ret);
    
      <span class="if">if</span> (s1-&gt;conf-&gt;malloc_bad)
        <span class="errno">errno</span> = ENOMEM, <span class="err">err</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"Add string data"</span>);

      w_state = io_put(s1, <span class="stdout">STDOUT_FILENO</span>);
    
      <span class="if">if</span> ((w_state == IO_BLOCK) &amp;&amp; (s1-&gt;len &gt; EX_MAX_W_DATA_INCORE))
        io_block(<span class="numm1">-1</span>, <span class="stdout">STDOUT_FILENO</span>);
    }
    
    mpz_add_ui(bignum_cnt, bignum_cnt, 1);
  }
}

<span class="int">int</span> main(<span class="int">int</span> argc, <span class="char">char</span> *argv[])
{
  <span class="vstrbase">Vstr_base</span> *s1 = ex_init(<span class="null">NULL</span>);
  <span class="mpzt">mpz_t</span> bignum_ret;
  <span class="mpzt">mpz_t</span> bignum_for;
  <span class="mpzt">mpz_t</span> bignum_cnt;
  <span class="int">int</span> cnt_max_sz = 1;
  <span class="int">int</span> ret_max_sz = 1;
  <span class="const">const</span> <span class="char">char</span> *loc_num_name = <span class="null">NULL</span>;
  
  <span class="if">if</span> (argc &lt; 2)
    <span class="err">errx</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"No count specified"</span>);

  <span class="comment">/* setup the custom format specifier for GMP ... see above
   */</span>
  vstr_cntl_conf(s1-&gt;conf, VSTR_CNTL_CONF_SET_FMT_CHAR_ESC, <span class="chr">'$'</span>);
  vstr_fmt_add(s1-&gt;conf, <span class="str">"&lt;MPZ:%p&gt;"</span>, ex_usr_mpz_cb,
               VSTR_TYPE_FMT_PTR_VOID, VSTR_TYPE_FMT_END);
  <span class="comment">/* second version so we can give a field width */</span>
  vstr_fmt_add(s1-&gt;conf, <span class="str">"&lt;MPZ:%*p&gt;"</span>, ex_usr_mpz_cb,
               VSTR_TYPE_FMT_PTR_VOID, VSTR_TYPE_FMT_END);

  <span class="comment">/* get the numeric locale name... */</span>
  setlocale(LC_ALL, <span class="str">""</span>);
  loc_num_name = setlocale(LC_NUMERIC, <span class="null">NULL</span>);
  
  <span class="comment">/* change grouping, from locale, to make numbers more readable */</span>
  <span class="if">if</span> (!vstr_cntl_conf(s1-&gt;conf, VSTR_CNTL_CONF_SET_LOC_CSTR_AUTO_NAME_NUMERIC,
                      loc_num_name))
    <span class="err">errx</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"Couldn't change numeric locale info"</span>);
  
  mpz_init_set_str(bignum_for, argv[1], <span class="num0">0</span>);
  mpz_init_set_str(bignum_ret,     <span class="str">"1"</span>, <span class="num0">0</span>);
  mpz_init_set_str(bignum_cnt,     <span class="str">"1"</span>, <span class="num0">0</span>);

  <span class="if">if</span> (EX_GMP_FACT_USE_FIELDWIDTH)
  { <span class="comment">/* find out the max length of the for values... */</span>

    <span class="comment">/* value of the count... */</span>
    vstr_add_fmt(s1, s1-&gt;len, <span class="str">"$'&lt;MPZ:%p&gt;"</span>, (<span class="void">void</span> *)bignum_for);
    <span class="if">if</span> (s1-&gt;conf-&gt;malloc_bad) <span class="comment">/* this checks a bunch of things above */</span>
      <span class="errno">errno</span> = ENOMEM, <span class="err">err</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"Add string data"</span>);
  
    cnt_max_sz = s1-&gt;len; vstr_del(s1, 1, s1-&gt;len);

    <span class="comment">/* work out the result */</span>
    <span class="if">if</span> (mpz_fits_ulong_p(bignum_for))
      mpz_fac_ui(bignum_ret, mpz_get_ui(bignum_for));
    <span class="else">else</span>
      ex_gmp_fact(bignum_ret, bignum_cnt, bignum_for, <span class="false">FALSE</span>, <span class="null">NULL</span>, <span class="num0">0</span>, <span class="num0">0</span>);

    <span class="comment">/* value of the result... */</span>
    <span class="if">if</span> (!vstr_add_fmt(s1, s1-&gt;len, <span class="str">"$'&lt;MPZ:%p&gt;"</span>, (<span class="void">void</span> *)bignum_ret))
      <span class="errno">errno</span> = ENOMEM, <span class="err">err</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"Add string data"</span>);
  
    ret_max_sz = s1-&gt;len; vstr_del(s1, 1, s1-&gt;len);

    <span class="comment">/* reinit, so we can print everything...  */</span>
    mpz_init_set_str(bignum_ret,     <span class="str">"1"</span>, <span class="num0">0</span>);
    mpz_init_set_str(bignum_cnt,     <span class="str">"1"</span>, <span class="num0">0</span>);
  }
  
  <span class="comment">/* do the output... */</span>
  <span class="if">if</span> (mpz_sgn(bignum_for) &gt;= <span class="num0">0</span>) <span class="comment">/* special case 0! */</span>
    <span class="if">if</span> (!vstr_add_fmt(s1, s1-&gt;len, <span class="str">"%*u%s %c %*u\n\n"</span>,
                      cnt_max_sz, <span class="num0">0</span>, <span class="str">"!"</span>, <span class="chr">'='</span>, ret_max_sz, 1))
      <span class="errno">errno</span> = ENOMEM, <span class="err">err</span>(<span class="exitfail">EXIT_FAILURE</span>, <span class="str">"Add string data"</span>);

  ex_gmp_fact(bignum_ret, bignum_cnt, bignum_for,
              <span class="true">TRUE</span>, s1, ret_max_sz, cnt_max_sz);
  
  io_put_all(s1, <span class="stdout">STDOUT_FILENO</span>);

  <span class="exit">exit</span> (ex_exit(s1, <span class="null">NULL</span>));
}
</pre>
<!-- C to html convertion of ex_gmp_factorials.c -->
<!--   done on Sun May  9 02:29:52 2004
 -->
<!--   done by ex_highlight -->

  </body>
</html>