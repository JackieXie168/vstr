<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>c2html for: ex_perf_nodesize.c</title>
    <link rel="stylesheet" type="text/css" href="f_c.css">
  </head>
  <body>
     <h1>ex_perf_nodesize.c</h1>
<pre class="c2html">
<span class="comment">/* This file tests how efficient differrent lengths of _BUF nodes are and also
 * compares them to one big pile
 * -- vstr is kind of built on the idea that this isn't a problem for
 *    reasonable sizes */</span>

#<span class="cppdefine">define</span> VSTR_COMPILE_INCLUDE 1

#<span class="cppinclude">include</span> &lt;vstr.h&gt;

#<span class="cppifndef">ifndef</span> TST_SZ <span class="comment">/* chunk size for custom Vstr */</span>
# <span class="cppdefine">define</span> TST_SZ (4096 - (sizeof(Vstr_node) + 8)) <span class="comment">/* one page each */</span>
#<span class="cppendif">endif</span>

#<span class="cppifndef">ifndef</span> TST_NUM <span class="comment">/* number of times to perform each test */</span>
# <span class="cppdefine">define</span> TST_NUM (1024 * 128)
#<span class="cppendif">endif</span>

#<span class="cppifndef">ifndef</span> TST_LEN <span class="comment">/* length of data for each test */</span>
# <span class="cppdefine">define</span> TST_LEN (512)
#<span class="cppendif">endif</span>

#<span class="cppifndef">ifndef</span> TST_MALLOC_EXTRA <span class="comment">/* malloc extra bytes before each loop */</span>
# <span class="cppdefine">define</span> TST_MALLOC_EXTRA (<span class="num0">0</span>)
#<span class="cppendif">endif</span>

#<span class="cppifndef">ifndef</span> TST_FREE <span class="comment">/* free the data from previous runs between each test */</span>
# <span class="cppdefine">define</span> TST_FREE (1)
#<span class="cppendif">endif</span>

#<span class="cppifndef">ifndef</span> TST_REUSE
# <span class="cppdefine">define</span> TST_REUSE (<span class="num0">0</span>)
#<span class="cppendif">endif</span>

#<span class="cppinclude">include</span> <span class="str">"ex_perf.h"</span>

#<span class="cppinclude">include</span> &lt;assert.h&gt;

<span class="int">int</span> main(<span class="void">void</span>)
{
  Vstr_conf *conf = <span class="null">NULL</span>;
  <span class="vstrbase">Vstr_base</span> *out = <span class="null">NULL</span>;
  <span class="vstrbase">Vstr_base</span> *s1 = <span class="null">NULL</span>;
  <span class="char">char</span> *s2 = <span class="null">NULL</span>;
  <span class="vstrbase">Vstr_base</span> *s3 = <span class="null">NULL</span>;
  <span class="unsigned">unsigned</span> <span class="int">int</span> err = <span class="num0">0</span>;
  <span class="char">char</span> *mal_overhead[TST_NUM];

  <span class="if">if</span> (!vstr_init())
    exit(<span class="exitfail">EXIT_FAILURE</span>);

  conf = vstr_make_conf();
  <span class="if">if</span> (!conf)
    exit(<span class="exitfail">EXIT_FAILURE</span>);

  <span class="comment">/* have a custom config. for output and s1 ... */</span>
  vstr_cntl_conf(conf, VSTR_CNTL_CONF_SET_NUM_BUF_SZ, TST_SZ);

  vstr_cntl_conf(conf, VSTR_CNTL_CONF_SET_LOC_CSTR_THOU_SEP, <span class="str">"_"</span>);
  vstr_cntl_conf(conf, VSTR_CNTL_CONF_SET_LOC_CSTR_THOU_GRP, <span class="str">"\3"</span>);

  vstr_cntl_conf(conf, VSTR_CNTL_CONF_SET_FMT_CHAR_ESC, <span class="chr">'$'</span>);
  vstr_sc_fmt_add_all(conf);

  out = vstr_make_base(conf); <span class="comment">/* used as stdio/stdout */</span>

  s1 = vstr_make_base(conf); <span class="comment">/* configured size */</span>
  s2 = malloc(TST_LEN); <span class="comment">/* single object */</span>
  s3 = vstr_make_base(<span class="null">NULL</span>); <span class="comment">/* default size */</span>
  vstr_free_conf(conf);
  <span class="if">if</span> (!out || !s1 || !s3)
    <span class="exit">exit</span> (<span class="exitfail">EXIT_FAILURE</span>);

  <span class="if">if</span> (!s2)
    <span class="exit">exit</span> (<span class="exitfail">EXIT_FAILURE</span>);

  <span class="comment">/* print table to say what config we are using ... */</span>
  vstr_add_fmt(out, out-&gt;len,
               <span class="str">"+${rep_chr:%c%zu}"</span>
               <span class="str">"+${rep_chr:%c%zu}"</span>
               <span class="str">"+${rep_chr:%c%zu}"</span>
               <span class="str">"+${rep_chr:%c%zu}+\n"</span>,
               <span class="chr">'='</span>, 17, <span class="chr">'='</span>, 18, <span class="chr">'='</span>, 18, <span class="chr">'='</span>, 18);
  vstr_add_fmt(out, out-&gt;len, <span class="str">"|%16s | %16s | %16s | %16s |\n"</span>,
               <span class="str">"name"</span>, <span class="str">"len"</span>, <span class="str">"chunks"</span>, <span class="str">"chunk size"</span>);

  vstr_add_fmt(out, out-&gt;len,
               <span class="str">"+${rep_chr:%c%zu}"</span>
               <span class="str">"+${rep_chr:%c%zu}"</span>
               <span class="str">"+${rep_chr:%c%zu}"</span>
               <span class="str">"+${rep_chr:%c%zu}+\n"</span>,
               <span class="chr">'-'</span>, 17, <span class="chr">'-'</span>, 18, <span class="chr">'-'</span>, 18, <span class="chr">'-'</span>, 18);
  {
    <span class="unsigned">unsigned</span> <span class="int">int</span> sz = <span class="num0">0</span>;

    vstr_cntl_conf(s1-&gt;conf, VSTR_CNTL_CONF_GET_NUM_BUF_SZ, &amp;sz);
    vstr_add_fmt(out, out-&gt;len,
                 <span class="str">"|%16s | $16{BKMG.u:%u} | %'16zu | $16{BKMG.u:%u} |\n"</span>,
                 <span class="str">"s1:  conf iovs"</span>, (<span class="unsigned">unsigned</span> <span class="int">int</span>) (TST_LEN * TST_NUM),
                 ((TST_LEN * TST_NUM) / sz) + 1, sz);

    vstr_add_fmt(out, out-&gt;len,
                 <span class="str">"|%16s | $16{BKMG.u:%u} | %'16zu | $16{BKMG.u:%u} |\n"</span>,
                 <span class="str">"s2:       mmap"</span>, (<span class="unsigned">unsigned</span> <span class="int">int</span>) (TST_LEN * TST_NUM),
                 TST_NUM, TST_LEN);

    vstr_cntl_conf(s3-&gt;conf, VSTR_CNTL_CONF_GET_NUM_BUF_SZ, &amp;sz);
    vstr_add_fmt(out, out-&gt;len,
                 <span class="str">"|%16s | $16{BKMG.u:%u} | %'16zu | $16{BKMG.u:%u} |\n"</span>,
                 <span class="str">"s3:   def iovs"</span>, (<span class="unsigned">unsigned</span> <span class="int">int</span>) (TST_LEN * TST_NUM),
                 ((TST_LEN * TST_NUM) / sz) + 1, sz);
  }
  vstr_add_fmt(out, out-&gt;len,
               <span class="str">"+${rep_chr:%c%zu}"</span>
               <span class="str">"+${rep_chr:%c%zu}"</span>
               <span class="str">"+${rep_chr:%c%zu}"</span>
               <span class="str">"+${rep_chr:%c%zu}+\n"</span>,
               <span class="chr">'-'</span>, 17, <span class="chr">'-'</span>, 18, <span class="chr">'-'</span>, 18, <span class="chr">'-'</span>, 18);

  vstr_add_fmt(out, out-&gt;len,
               <span class="str">" Doing tests %'u times with extra malloc of %u:\n"</span>,
               (<span class="unsigned">unsigned</span> <span class="int">int</span>)TST_NUM, TST_MALLOC_EXTRA);

  err = <span class="num0">0</span>;
  <span class="while">while</span> (out-&gt;len &amp;&amp; !err)
    vstr_sc_write_fd(out, 1, out-&gt;len, 1 <span class="comment">/* stdout */</span>, &amp;err);

  TST_HDR_BEG();

  TST_BEG(1, 1);
  mal_overhead[tst_count] = malloc(64 - 8);
  buf_out[0] = <span class="chr">'x'</span>;
  TST_END(<span class="str">"single malloc "</span>);

  <span class="for">for</span> (err = <span class="num0">0</span>; err &lt; 1; ++err)
    free(mal_overhead[err]);

  TST_BEG(1, TST_NUM);
  <span class="if">if</span> (TST_MALLOC_EXTRA)
    mal_overhead[tst_count] = malloc(TST_MALLOC_EXTRA);
  buf_out[0] = <span class="chr">'x'</span>;
  <span class="if">if</span> (TST_REUSE)
    vstr_del(s1, 1, s1-&gt;len);
  vstr_add_rep_chr(s1, s1-&gt;len, buf_out[0], TST_LEN);
  TST_END(<span class="str">"s1:  conf iovs"</span>);

  <span class="if">if</span> (TST_FREE)
  {
    vstr_del(s1, 1, s1-&gt;len);
    <span class="if">if</span> (TST_MALLOC_EXTRA)
      <span class="for">for</span> (err = <span class="num0">0</span>; err &lt; TST_NUM; ++err)
        free(mal_overhead[err]);
  }

  TST_BEG(1, TST_NUM);
  <span class="unsigned">unsigned</span> <span class="int">int</span> off     = (TST_LEN * tst_count);
  <span class="unsigned">unsigned</span> <span class="int">int</span> new_len = off + TST_LEN;

  <span class="if">if</span> (TST_MALLOC_EXTRA)
    mal_overhead[tst_count] = malloc(TST_MALLOC_EXTRA);
  buf_out[0] = <span class="chr">'x'</span>;
  <span class="if">if</span> (TST_REUSE)
    off = <span class="num0">0</span>;
  <span class="else">else</span>
    s2 = realloc(s2, new_len);
  <span class="if">if</span> (!s2)
    <span class="goto">goto</span> failed;
  memset(s2 + off, buf_out[0], TST_LEN);
  TST_END(<span class="str">"s2:     malloc"</span>);

  <span class="if">if</span> (TST_FREE)
  {
    free(s2); s2 = <span class="null">NULL</span>;
    <span class="if">if</span> (TST_MALLOC_EXTRA)
      <span class="for">for</span> (err = <span class="num0">0</span>; err &lt; TST_NUM; ++err)
        free(mal_overhead[err]);
  }

  TST_BEG(1, TST_NUM);
  <span class="if">if</span> (TST_MALLOC_EXTRA)
    mal_overhead[tst_count] = malloc(TST_MALLOC_EXTRA);
  buf_out[0] = <span class="chr">'x'</span>;
  <span class="if">if</span> (TST_REUSE)
    vstr_del(s3, 1, s3-&gt;len);
  vstr_add_rep_chr(s3, s3-&gt;len, buf_out[0], TST_LEN);
  TST_END(<span class="str">"s3:   def iovs"</span>);

  <span class="if">if</span> (TST_FREE)
  {
    vstr_del(s3, 1, s3-&gt;len);
    <span class="if">if</span> (TST_MALLOC_EXTRA)
      <span class="for">for</span> (err = <span class="num0">0</span>; err &lt; TST_NUM; ++err)
        free(mal_overhead[err]);
  }

  TST_HDR_END();

  <span class="if">if</span> (s1-&gt;conf-&gt;malloc_bad || s3-&gt;conf-&gt;malloc_bad)
    <span class="goto">goto</span> failed;

  err = <span class="num0">0</span>;
  <span class="while">while</span> (out-&gt;len &amp;&amp; !err)
    vstr_sc_write_fd(out, 1, out-&gt;len, 1 <span class="comment">/* stdout */</span>, &amp;err);

  vstr_free_base(out);
  vstr_free_base(s1);
  free(s2);
  vstr_free_base(s3);

  vstr_exit();

  <span class="exit">exit</span> (<span class="exitsucs">EXIT_SUCCESS</span>);

 failed:
  err = <span class="num0">0</span>;
  <span class="while">while</span> (out-&gt;len &amp;&amp; !err)
    vstr_sc_write_fd(out, 1, out-&gt;len, 2 <span class="comment">/* stderr */</span>, &amp;err);

  vstr_free_base(out);
  vstr_free_base(s1);
  free(s2);
  vstr_free_base(s3);

  vstr_exit();

  <span class="exit">exit</span> (<span class="exitfail">EXIT_FAILURE</span>);
}

</pre>
<!-- C to html convertion of ex_perf_nodesize.c -->
<!--   done on Sun May  9 02:29:53 2004
 -->
<!--   done by ex_highlight -->

  </body>
</html>