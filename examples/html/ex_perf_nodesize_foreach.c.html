<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>c2html for: ex_perf_nodesize_foreach.c</title>
    <link rel="stylesheet" type="text/css" href="f_c.css">
  </head>
  <body>
     <h1>ex_perf_nodesize_foreach.c</h1>
<pre class="c2html">
<span class="comment">/* This file tests how efficient differrent lengths of _BUF nodes are and also
 * compares them to one big pile
 * -- vstr is kind of built on the idea that this isn't a problem for
 *    reasonable sizes */</span>

#<span class="cppdefine">define</span> VSTR_COMPILE_INCLUDE 1

#<span class="cppinclude">include</span> &lt;vstr.h&gt;

#<span class="cppif">if</span> <span class="num0">0</span>
# <span class="cppdefine">define</span> TST_SZ_BEG (64 - (16 + 8))
# <span class="cppdefine">define</span> TST_SZ_INC ((sz == (64 - (16 + 8)))   ? (16 + 8) : \
                     (sz == 64)                ? (64 - (16 + 8)) : \
                     (sz == (128 - (16 + 8)))  ? (16 + 8) : \
                     (sz == 128)               ? (128 - (16 + 8)) : \
                     (sz == (256 - (16 + 8)))  ? (16 + 8) : \
                     (sz == 256)               ? (256 - (16 + 8)) : \
                     (sz == (512 - (16 + 8)))  ? (16 + 8) : \
                     (sz == 512)               ? (512 - (16 + 8)) : \
                     (sz == (1024 - (16 + 8))) ? (16 + 8) : \
                     (sz == 1024)              ? (3072 - (16 + 8)) : \
                     (sz == (4096 - (16 + 8))) ? (16 + 8) : 1)
# <span class="cppdefine">define</span> TST_SZ_END (4096)
#<span class="cppelse">else</span>
# <span class="cppdefine">define</span> TST_SZ_BEG (512 - (16 + 8))
# <span class="cppdefine">define</span> TST_SZ_INC ((sz == (512 - (16 + 8)))  ? (16 + 8) : \
                     (sz == 512)               ? (512 + 3072 - (16 + 8)) : \
                     (sz == (4096 - (16 + 8))) ? (16 + 8) : 1)
# <span class="cppdefine">define</span> TST_SZ_END (4096)
#<span class="cppendif">endif</span>

<span class="comment">/* #define TST_SZ_END (4096 - (sizeof(Vstr_node) + 16)) */</span>

<span class="comment">/*
  #define TST_NUM_BEG (64)
  #define TST_NUM_END (1024)
*/</span>
#<span class="cppdefine">define</span> TST_NUM_BEG (4096)
#<span class="cppdefine">define</span> TST_NUM_INC (1)
#<span class="cppdefine">define</span> TST_NUM_END (4096)

#<span class="cppdefine">define</span> TST_LEN_BEG (sz &gt;= 128 ? 128 : 1)
#<span class="cppdefine">define</span> TST_LEN_INC (1)
#<span class="cppdefine">define</span> TST_LEN_END (1024 * 100)

#<span class="cppdefine">define</span> TST_MALLOC_EXTRA_BEG (<span class="num0">0</span>)
#<span class="cppdefine">define</span> TST_MALLOC_EXTRA_INC (1024)
#<span class="cppdefine">define</span> TST_MALLOC_EXTRA_END (1024 * 2)

#<span class="cppdefine">define</span> TST_COUNT_BEG (1)
#<span class="cppdefine">define</span> TST_COUNT_INC (1)
#<span class="cppdefine">define</span> TST_COUNT_END (2)

#<span class="cppdefine">define</span> TST_USE_MEMCPY 1

#<span class="cppinclude">include</span> <span class="str">"ex_perf.h"</span>

#<span class="cppinclude">include</span> &lt;assert.h&gt;
#<span class="cppinclude">include</span> &lt;unistd.h&gt;

#<span class="cppinclude">include</span> &lt;glib.h&gt;


 <span class="comment">/* this is M_TRIM_THRESH */</span>
#<span class="cppdefine">define</span> TST_ALLOC_TRIM() do { \
  struct mallinfo mal_info = mallinfo(); \
  trig_trim = malloc((128 * 1024) + mal_info.fordblks); \
  <span class="if">if</span> (!trig_trim) <span class="goto">goto</span> failed; \
} <span class="while">while</span> (<span class="num0">0</span>)

#<span class="cppdefine">define</span> TST_CLEANUP_TRIM(x) do { \
  <span class="unsigned">unsigned</span> <span class="int">int</span> clean_extra = num; \
  \
  <span class="if">if</span> (extra) \
    <span class="while">while</span> (clean_extra--) \
      free(mal_overhead[clean_extra]); \
  \
  <span class="if">if</span> (x) free(trig_trim); \
} <span class="while">while</span> (<span class="num0">0</span>)


<span class="int">int</span> main(<span class="void">void</span>)
{
  Vstr_conf *conf = <span class="null">NULL</span>;
  <span class="vstrbase">Vstr_base</span> *out = <span class="null">NULL</span>;
  <span class="vstrbase">Vstr_base</span> *s1 = <span class="null">NULL</span>;
  <span class="char">char</span> *s2 = <span class="null">NULL</span>;
  GString *s3 = <span class="null">NULL</span>;
  <span class="char">char</span> *s4 = <span class="null">NULL</span>;
  <span class="unsigned">unsigned</span> <span class="int">int</span> ern = <span class="num0">0</span>;
  <span class="char">char</span> *mal_overhead[TST_NUM_END];
  <span class="char">char</span> *s3_data = <span class="null">NULL</span>;

  mallopt(M_MMAP_MAX, <span class="num0">0</span>); <span class="comment">/* mmap() can change the results */</span>

  <span class="if">if</span> (!vstr_init())
    exit(<span class="exitfail">EXIT_FAILURE</span>);

  conf = vstr_make_conf();
  <span class="if">if</span> (!conf)
    exit(<span class="exitfail">EXIT_FAILURE</span>);

  out = vstr_make_base(<span class="null">NULL</span>); <span class="comment">/* used as stdio/stdout */</span>
  <span class="if">if</span> (!out)
    <span class="exit">exit</span> (<span class="exitfail">EXIT_FAILURE</span>);

  s3_data = malloc(TST_LEN_END);
  <span class="if">if</span> (!s3_data)
    <span class="goto">goto</span> failed;
  memset(s3_data, <span class="chr">'x'</span>, TST_LEN_END);

  vstr_cntl_conf(<span class="null">NULL</span>, VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_BUF, 128, 128);

  <span class="if">if</span> (1)
  {
    <span class="unsigned">unsigned</span> <span class="int">int</span> sz = TST_SZ_BEG;
    <span class="while">while</span> (sz &lt;= TST_SZ_END)
    {
    <span class="unsigned">unsigned</span> <span class="int">int</span> len = TST_LEN_BEG;

    vstr_free_base(s1);
    vstr_cntl_conf(conf, VSTR_CNTL_CONF_SET_NUM_BUF_SZ, sz);
    s1 = vstr_make_base(conf);
    <span class="if">if</span> (!s1)
      <span class="goto">goto</span> failed;

    <span class="while">while</span> (len &lt;= TST_LEN_END)
    {
    <span class="unsigned">unsigned</span> <span class="int">int</span> num = TST_NUM_BEG;
    <span class="while">while</span> (num &lt;= TST_NUM_END)
    {
    <span class="unsigned">unsigned</span> <span class="int">int</span> extra = TST_MALLOC_EXTRA_BEG;
    <span class="while">while</span> (extra &lt;= TST_MALLOC_EXTRA_END)
    {
    <span class="unsigned">unsigned</span> <span class="int">int</span> count = TST_COUNT_BEG;
    <span class="while">while</span> (count &lt;= TST_COUNT_END)
    {
      <span class="void">void</span> *trig_trim = <span class="null">NULL</span>;

      TST_ALLOC_TRIM();

      TST_BEG(1, num);
      <span class="if">if</span> (extra)
        mal_overhead[tst_count] = malloc(extra);
      buf_out[0] = <span class="chr">'x'</span>;
      <span class="if">if</span> (TST_USE_MEMCPY)
        vstr_add_buf(s1, s1-&gt;len, s3_data, len);
      <span class="else">else</span>
        vstr_add_rep_chr(s1, s1-&gt;len, buf_out[0], len);
      TST_CALC_END(<span class="str">"V"</span>);

      vstr_del(s1, 1, s1-&gt;len);
      TST_CLEANUP_TRIM(<span class="num0">0</span>);

      TST_BEG(1, num);
      <span class="if">if</span> (extra)
        mal_overhead[tst_count] = malloc(extra);
      buf_out[0] = <span class="chr">'x'</span>;
      <span class="if">if</span> (TST_USE_MEMCPY)
        vstr_add_buf(s1, s1-&gt;len, s3_data, len);
      <span class="else">else</span>
        vstr_add_rep_chr(s1, s1-&gt;len, buf_out[0], len);
      TST_CALC_END(<span class="str">"A"</span>);

      vstr_del(s1, 1, s1-&gt;len);
      vstr_cntl_conf(conf, VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_BUF, <span class="num0">0</span>, <span class="num0">0</span>);
      TST_CLEANUP_TRIM(1);
      TST_ALLOC_TRIM();

      s2 = malloc(sz); <span class="comment">/* single object */</span>
      <span class="if">if</span> (!s2)
        <span class="goto">goto</span> failed;

      TST_BEG(1, num);
      <span class="unsigned">unsigned</span> <span class="int">int</span> off     = (len * tst_count);
      <span class="unsigned">unsigned</span> <span class="int">int</span> new_len = off + len;
      <span class="if">if</span> (extra)
        mal_overhead[tst_count] = malloc(extra);
      buf_out[0] = <span class="chr">'x'</span>;
      s2 = realloc(s2, new_len);
      <span class="if">if</span> (!s2)
        <span class="goto">goto</span> failed;
      <span class="if">if</span> (TST_USE_MEMCPY)
        memcpy(s2 + off, s3_data,    len);
      <span class="else">else</span>
        memset(s2 + off, buf_out[0], len);
      TST_CALC_END(<span class="str">"S"</span>);

      free(s2);
      s2 = <span class="null">NULL</span>;
      TST_CLEANUP_TRIM(1);
      TST_ALLOC_TRIM();

      <span class="if">if</span> (TST_USE_MEMCPY)
      {
        s3 = g_string_sized_new(sz);
        TST_BEG(1, num);
        <span class="if">if</span> (extra)
          mal_overhead[tst_count] = malloc(extra);
        buf_out[0] = <span class="chr">'x'</span>;
        g_string_append_len(s3, s3_data, len);
        TST_CALC_END(<span class="str">"G"</span>);

        g_string_free(s3, <span class="true">TRUE</span>);
        s3 = <span class="null">NULL</span>;
        TST_CLEANUP_TRIM(1);
        TST_ALLOC_TRIM();

        TST_BEG(1, num);
        <span class="if">if</span> (extra)
          mal_overhead[tst_count] = malloc(extra);
        buf_out[0] = <span class="chr">'x'</span>;
        vstr_add_ptr(s1, s1-&gt;len, s3_data, len);
        TST_CALC_END(<span class="str">"P"</span>);

        vstr_del(s1, 1, s1-&gt;len);
        vstr_cntl_conf(conf, VSTR_CNTL_CONF_SET_NUM_RANGE_SPARE_PTR, <span class="num0">0</span>, <span class="num0">0</span>);
        TST_CLEANUP_TRIM(1);
        TST_ALLOC_TRIM();
      }

      s4 = malloc(len); <span class="comment">/* single object */</span>
      <span class="if">if</span> (!s4)
        <span class="goto">goto</span> failed;

      TST_BEG(1, num);
      <span class="if">if</span> (extra)
        mal_overhead[tst_count] = malloc(extra);
      buf_out[0] = <span class="chr">'x'</span>;
      <span class="if">if</span> (TST_USE_MEMCPY)
        memcpy(s4, s3_data,    len);
      <span class="else">else</span>
        memset(s4, buf_out[0], len);
      TST_CALC_END(<span class="str">"B"</span>);

      free(s4);
      s4 = <span class="null">NULL</span>;
      TST_CLEANUP_TRIM(1);

      <span class="if">if</span> (out-&gt;len)
        vstr_sc_write_fd(out, 1, out-&gt;len, 1 <span class="comment">/* stdout */</span>, &amp;ern);
      <span class="if">if</span> (ern)
        <span class="goto">goto</span> failed;

      count += TST_COUNT_INC;
    }
      extra += TST_MALLOC_EXTRA_INC;
    }
      num   += TST_NUM_INC;
    }
      len   += TST_LEN_INC;
    }
      sz    += TST_SZ_INC;
    }
  }

  <span class="if">if</span> (s1-&gt;conf-&gt;malloc_bad || out-&gt;conf-&gt;malloc_bad)
    <span class="goto">goto</span> failed;

  <span class="while">while</span> (out-&gt;len &amp;&amp; !ern)
    vstr_sc_write_fd(out, 1, out-&gt;len, <span class="stdout">STDOUT_FILENO</span>, &amp;ern);

  vstr_free_conf(conf);
  vstr_free_base(out);
  vstr_free_base(s1);
  free(s2);

  vstr_exit();

  <span class="exit">exit</span> (<span class="exitsucs">EXIT_SUCCESS</span>);

 failed:
  ern = <span class="num0">0</span>;
  <span class="while">while</span> (out-&gt;len &amp;&amp; !ern)
    vstr_sc_write_fd(out, 1, out-&gt;len, <span class="stderr">STDERR_FILENO</span>, &amp;ern);

  vstr_free_base(out);
  vstr_free_base(s1);
  free(s2);

  vstr_exit();

  <span class="exit">exit</span> (<span class="exitfail">EXIT_FAILURE</span>);
}

</pre>
<!-- C to html convertion of ex_perf_nodesize_foreach.c -->
<!--   done on Mon Jan 26 05:27:54 2004
 -->
<!--   done by ex_highlight -->

  </body>
</html>